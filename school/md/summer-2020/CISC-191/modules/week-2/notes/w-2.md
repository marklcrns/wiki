---
title: Week 2
author: Mark Lucernas
date: 2020-06-23
summary: Object Oriented Programming
---


# Week 2: Object Oriented Programming

## UML

  - [Unified Modeling Language (UML)](https://www.cs.bsu.edu/homepages/pvgestwicki/misc/uml/)

### Sign Indicators

  - `-`          = indicates private modifier
  - `+`          = indicates public modifier
  - `#`          = indicates protected modifier
  - `underlined` = indicates static visibility


## Objects and Classes

  - [*Objects and Classes](file:../../../../../../files/summer-2020/CISC-191/week-2/objects_and_classes.ppt)


Object-oriented programming (OOP) involves programming using objects. An object
represents an entity in the real world that can be distinctly identified. For
example, a student, a desk, a circle, a button, and even a loan can all be
viewed as objects. An object has a unique identity, state, and behaviors. The
state of an object consists of a set of data fields (also known as properties)
with their current values. The behavior of an object is defined by a set of
methods.

<a name="static-variables-constants-and-methods-term">**Static variables, constants, and methods**</a>

  - Static variables are shared by all the instances of the class.
  - Static methods are not tied to a specific object.
  - Static constants are final variables shared by all the instances of the
    class.


<a name="visibility-modifiers-term">**Visibility modifiers**</a>

  - _public_
    * The class, data, or method is visible to any class in any package.
  - _private_
    * The data or methods can be accessed only by the declaring class.
  - The private modifier restricts access to within a class, the default
    modifier restricts access to within a package, and the public modifier
    enables unrestricted access.


<a name="immutable-term">**Immutable**</a>

  - If the contents of an object cannot be changed once the object is created,
    the object is called an _immutable_ object and its class is called an
    _immutable_ class.
  - For a class to be immutable, it must mark all data fields private and
    provide no _mutator_ methods (getters) and no _accessor_ methods (setters)
    that would return a reference to a mutable data field object.


### Modifier Scope

private   = class
Default   = class, package
protected = class, package, subclass
public    = class, package, subclass, outside package


## Object-Oriented Thinking

  - [*Object-Oriented Thinking](file:../../../../../../files/summer-2020/CISC-191/week-2/object-oriented_thinking.ppt)


<a name="class-abstraction-and-encapsulation-term">**Class abstraction and encapsulation**</a>

  - Class abstraction means to separate class implementation from the use of the
    class. The creator of the class provides a description of the class and let
    the user know how the class can be used. The user of the class does not need
    to know how the class is implemented. The detail of implementation is
    encapsulated and hidden from the user.


<a name="object-composition-term">**Object composition**</a>

  - Composition is actually a special case of the aggregation relationship.
    Aggregation models has-a relationships and represents an ownership
    relationship between two objects. The owner object is called an
    _aggregating_ object and its class an _aggregating_ class. The subject
    object is called an _aggregated_ object and its class an _aggregated_ class.


### Wrapper Classes

The wrapper classes do not have no-arg constructors. (2) The instances of all
wrapper classes are immutable, i.e., their internal values cannot be changed
once the objects are created.

  - `Boolean`
  - `Character`
  - `Short`
  - `Byte`
  - `Integer`
  - `Long`
  - `Float`
  - `Double`


#### Numeric Wrapper Class Constructors

You can construct a wrapper object either from a primitive data type value or
from a string representing the numeric value. The constructors for Integer and
Double are:

```java
public Integer(int value)
public Integer(String s)
public Double(double value)
public Double(String s)
```

Each numerical wrapper class has the constants MAX_VALUE and MIN_VALUE.
MAX_VALUE represents the maximum value of the corresponding primitive data type.
For Byte, Short, Integer, and Long, MIN_VALUE represents the minimum byte,
short, int, and long values. For Float and Double, MIN_VALUE represents the
minimum positive float and double values. The following statements display the
maximum integer (2,147,483,647), the minimum positive float (1.4E-45), and the
maximum double floating-point number (1.79769313486231570e+308d).

#### Conversion Methods

Each numeric wrapper class implements the abstract methods doubleValue,
floatValue, intValue, longValue, and shortValue, which are defined in the Number
class. These methods “convert” objects into primitive type values.


### The String Class

A String object is immutable; its contents cannot be changed.

#### Interned Strings

Since strings are immutable and are frequently used, to improve efficiency and
save memory, the JVM uses a unique instance for string literals with the same
character sequence. Such an instance is called interned.

> A new object is created if you use the new operator.  If you use the string
initializer, no new object is created if the interned object is already created.

#### StringBuilder and StringBuffer

The `StringBuilder`/`StringBuffer` class is an alternative to the String class.
In general, a `StringBuilder`/`StringBuffer` can be used wherever a string is
used.  `StringBuilder`/`StringBuffer` is more flexible than String. You can add,
insert, or append new contents into a string buffer, whereas the value of a
String object is fixed once the string is created.


### Regular Expressions

A regular expression (abbreviated regex) is a string that describes a pattern
for matching a set of strings. Regular expression is a powerful tool for string
manipulations. You can use regular expressions for matching, replacing, and
splitting strings.


## Inheritance and Polymorphism

  - [*Inheritance and Polymorphism](file:../../../../../../files/summer-2020/CISC-191/week-2/inheritance_and_polymorphism.ppt)


### Superclasses and Subclasses

The keyword super refers to the superclass of the class in which super appears.
This keyword can be used in two ways:

  - To call a superclass constructor. `super()`
  - To call a superclass method. `super.methodName()`

#### Are Superclass’s Constructor Inherited?

No. They are not inherited. They are invoked explicitly or implicitly.

Explicitly using the super keyword.

  - A constructor is used to construct an instance of a class. Unlike properties
    and methods, a superclass's constructors are not inherited in the subclass.
    They can only be invoked from the subclasses' constructors, using the
    keyword _super_. If the keyword _super_ is not explicitly used, the
    superclass's no-arg constructor is automatically invoked.


#### Superclass’s Constructor Is Always Invoked

A constructor may invoke an overloaded constructor or its superclass’s
constructor. If none of them is invoked explicitly, the compiler puts super() as
the first statement in the constructor.

#### Overriding Methods in the Superclass

A subclass inherits methods from a superclass. Sometimes it is necessary for the
subclass to modify the implementation of a method defined in the superclass.
This is referred to as method overriding.

```java
public class Circle extends GeometricObject {
  // Other methods are omitted

  /** Override the toString method defined in GeometricObject */
  public String toString() {
    return super.toString() + "\nradius is " + radius;
  }
}
```

> An instance method can be overridden only if it is accessible. Thus a private
method cannot be overridden, because it is not accessible outside its own class.
If a method defined in a subclass is private in its superclass, the two methods
are completely unrelated.

> Like an instance method, a static method can be inherited. However, a static
method cannot be overridden. If a static method defined in the superclass is
redefined in a subclass, the method defined in the superclass is hidden.

### Polymorphism

_Polymorphism_ means that a variable of a supertype can refer to a subtype
object.

A class defines a type. A type defined by a subclass is called a subtype, and a
type defined by its superclass is called a supertype. Therefore, you can say
that Circle is a subtype of GeometricObject and GeometricObject is a supertype
for Circle.

```java
public class PolymorphismDemo {
  public static void main(String[] args) {
    m(new GraduateStudent());
    m(new Student());
    m(new Person());
    m(new Object());
  }
 
  public static void m(Object x) {
    System.out.println(x.toString());
  }
}
 
class GraduateStudent extends Student {
}
 
class Student extends Person {
  public String toString() {
    return "Student";
  }
}
 
class Person extends Object {
  public String toString() {
    return "Person";
  }
}
```

An object of a subtype can be used wherever its supertype value is required.
This feature is known as _polymorphism_.

When the method m(Object x) is executed, the argument x’s toString method is
invoked. x may be an instance of GraduateStudent, Student, Person, or Object.
Classes GraduateStudent, Student, Person, and Object have their own
implementation of the toString method. Which implementation is used will be
determined dynamically by the Java Virtual Machine at runtime. This capability
is known as dynamic binding.

Polymorphism allows methods to be used generically for a wide range of object
arguments. This is known as **generic programming**. If a method’s parameter
type is a superclass (e.g., Object), you may pass an object to this method of
any of the parameter’s subclasses (e.g., Student or String). When an object
(e.g., a Student object or a String object) is used in the method, the
particular implementation of the method of the object that is invoked (e.g.,
toString) is determined dynamically.

### Dynamic Binding

Dynamic binding works as follows: Suppose an object `o` is an instance of
classes $C_{1}$, $C_{2}$, ..., $C_{n-1}$, and $C_{n}$, where $C_{1}$ is a
subclass of $C_{2}$, $C_{2}$ is a subclass of $C_{3}$, ..., and $C_{n-1}$ is a
subclass of $C_{n}$. That is, $C_{n}$ is the most general class, and $C_{1}$ is
the most specific class. In Java, $C_{n}$ is the Object class. If `o` invokes a
method `p`, the JVM searches the implementation for the method `p` in $C_{1}$,
$C_{2}$, ..., $C_{n-1}$ and $C_{n}$, in this order, until it is found. Once an
implementation is found, the search stops and the first-found implementation is
invoked.

### Method Matching vs. Binding

Matching a method signature and binding a method implementation are two issues.
The compiler finds a matching method according to parameter type, number of
parameters, and order of the parameters at compilation time. A method may be
implemented in several subclasses. The Java Virtual Machine dynamically binds
the implementation of the method at runtime.

### Casting Objects

You have already used the casting operator to convert variables of one primitive
type to another. Casting can also be used to convert an object of one class type
to another within an inheritance hierarchy. In the preceding section, the
statement

```java
m(new Student());
```

assigns the object new Student() to a parameter of the Object type. This
statement is equivalent to:

```java
Object o = new Student(); // Implicit casting
m(o);
```

The statement Object o = new Student(), known as implicit casting, is legal
because an instance of Student is automatically an instance of Object.

### Why Casting Is Necessary?

Suppose you want to assign the object reference o to a variable of the Student
type using the following statement:

```java
Student b = o;
```

A compile error would occur. Why does the statement Object o = new Student()
work and the statement Student b = o doesn’t? This is because a Student object
is always an instance of Object, but an Object is not necessarily an instance of
Student. Even though you can see that o is really a Student object, the compiler
is not so clever to know it. To tell the compiler that o is a Student object,
use an explicit casting. The syntax is similar to the one used for casting among
primitive data types. Enclose the target object type in parentheses and place it
before the object to be cast, as follows:

```java
Student b = (Student)o; // Explicit casting
```

> Explicit casting must be used when casting an object from a superclass to a
subclass.  This type of casting may not always succeed.

### The instanceof Operator

Use the `instanceof` operator to test whether an object is an instance of a
class:

```java
Object myObject = new Circle();
... // Some lines of code
/** Perform casting if myObject is an instance of Circle */
if (myObject instanceof Circle) {
  System.out.println("The circle diameter is " +
    ((Circle)myObject).getDiameter());
  ...
}
```

### The equals Method

The `equals()` method compares the contents of two objects. The default
implementation of the equals method in the Object class is as follows:

```java
public boolean equals(Object o) {
  if (o instanceof Circle) {
    return radius == ((Circle)o).radius;
  }
  else
    return false;
}
```

> The == comparison operator is used for comparing two primitive data type
values or for determining whether two objects have the same references. The
equals method is intended to test whether two objects have the same contents,
provided that the method is modified in the defining class of the objects. The
== operator is stronger than the equals method, in that the == operator checks
whether the two reference variables refer to the same object.

### The ArrayList Class

You can create an array to store objects. But the array’s size is fixed once the
array is created. Java provides the ArrayList class that can be used to store an
unlimited number of objects.

`java.util.ArralyList<E>`

ArrayList is known as a generic class with a generic type `E`. You can specify a
concrete type to replace `E` when creating an `ArrayList`. For example, the
following statement creates an `ArrayList` and assigns its reference to variable
`cities`. This `ArrayList` object can be used to store strings.

```java
ArrayList<String> cities = new ArrayList<String>();
ArrayList<String> cities = new ArrayList<>();
```

#### Array Lists from/to Arrays

Creating an ArrayList from an array of objects:

```java
String[] array = {"red", "green", "blue"};
ArrayList<String> list = new ArrayList<>(Arrays.asList(array));
```

Creating an array of objects from an ArrayList:

```java
String[] array1 = new String[list.size()];
list.toArray(array1);
```

#### max and min in an Array List

```java
String[] array = {"red", "green", "blue"};
System.out.pritnln(java.util.Collections.max(
   new ArrayList<String>(Arrays.asList(array)));
```

```java
String[] array = {"red", "green", "blue"};
System.out.pritnln(java.util.Collections.min(
  new ArrayList<String>(Arrays.asList(array)));
```

#### Shuffling an Array List

```java
Integer[] array = {3, 5, 95, 4, 15, 34, 3, 6, 5};
ArrayList<Integer> list = new
  ArrayList<>(Arrays.asList(array));
java.util.Collections.shuffle(list);
System.out.println(list);
```

### The protected Modifier

  - The `protected` modifier can be applied on data and methods in a class. A
    protected data or a `protected` method in a public class can be accessed by
    any class in the same package or its subclasses, **even if the subclasses
    are in a different package**.

  - Visibility increases in this order:
    * private, default, protected, public


### A Subclass Cannot Weaken the Accessibility

A subclass may override a protected method in its superclass and change its
visibility to public. However, a subclass cannot weaken the accessibility of a
method defined in the superclass. For example, if a method is defined as public
in the superclass, it must be defined as public in the subclass.

> The modifiers are used on classes and class members (data and methods), except
that the final modifier can also be used on local variables in a method. A final
local variable is a constant inside a method.

### The final Modifier

  - The final class cannot be extended:

```java
final class Math {
  ...
}
```

  - The final variable is a constant:

```java
final static double PI = 3.14159;
```

  - The final method cannot be
    overridden by its subclasses.


## Exceptions Handling and Text IO

  - [*Exceptions Handling](file:../../../../../../files/summer-2020/CISC-191/week-2/exceptions_handling.ppt)


### System Errors

System _errors_ are thrown by JVM and represented in the `Error` class. The
`Error` class describes internal system errors. Such errors rarely occur. If one
does, there is little you can do beyond notifying the user and trying to
terminate the program gracefully.

### Exceptions

_Exception_ describes errors caused by your program and external circumstances.
These errors can be caught and handled by your program.

### Runtime Exceptions

RuntimeException is caused by programming errors, such as bad casting, accessing
an out-of-bounds array, and numeric errors.

### Checked Exceptions vs. Unchecked Exceptions

`RuntimeException`, `Error` and their subclasses are known as _unchecked
exceptions_.  All other exceptions are known as _checked exceptions_, meaning
that the compiler forces the programmer to check and deal with the exceptions.

#### Unchecked Exceptions

In most cases, unchecked exceptions reflect programming logic errors that are
not recoverable. For example, a `NullPointerException` is thrown if you access
an object through a reference variable before an object is assigned to it; an
`IndexOutOfBoundsException` is thrown if you access an element in an array
outside the bounds of the array. These are the logic errors that should be
corrected in the program. Unchecked exceptions can occur anywhere in the
program. To avoid cumbersome overuse of try-catch blocks, Java does not mandate
you to write code to catch unchecked exceptions.

### Declaring Exceptions

Every method must state the types of checked exceptions it might throw. This is
known as _declaring exceptions_.

```java
public void myMethod() throws IOException
public void myMethod() throws IOException, OtherException
```

### Throwing Exceptions

When the program detects an error, the program can create an instance of an
appropriate exception type and throw it. This is known as throwing an exception.
Here is an example,

```java
throw new TheException();
TheException ex = new TheException();
throw ex;
```

Example

```java
/** Set a new radius */
public void setRadius(double newRadius) throws IllegalArgumentException {
  if (newRadius >= 0)
    radius =  newRadius;
  else
    throw new IllegalArgumentException("Radius cannot be negative");
}
```

### Catching Exceptions

```java
try {
  statements;  // Statements that may throw exceptions
}
catch (Exception1 exVar1) {
  handler for exception1;
}
catch (Exception2 exVar2) {
  handler for exception2;
}
...
catch (ExceptionN exVar3) {
  handler for exceptionN;
}
```

### Catch or Declare Checked Exceptions

Java forces you to deal with checked exceptions. If a method declares a checked
exception (i.e., an exception other than `Error` or `RuntimeException`), you must
invoke it in a try-catch block or declare to throw the exception in the calling
method.

### Rethrowing Exceptions

try {
  statements;
}
catch(TheException ex) {
  perform operations before exits;
  throw ex;
}

### The finally Clause

```java
try {
  statements;
}
catch(TheException ex) {
  handling ex;
}
finally {
  finalStatements;
}
```

### Cautions When Using Exceptions

Exception handling separates error-handling code from normal programming tasks,
thus making programs easier to read and to modify. Be aware, however, that
exception handling usually requires more time and resources because it requires
instantiating a new exception object, rolling back the call stack, and
propagating the errors to the calling methods.


### When to Throw Exceptions

An exception occurs in a method. If you want the exception to be processed by
its caller, you should create an exception object and throw it. If you can
handle the exception in the method where it occurs, there is no need to throw
it.

### When to Use Exceptions

When should you use the try-catch block in the code? You should use it to deal
with unexpected error conditions. Do not use it to deal with simple, expected
situations. For example, the following code

```java
try {
  System.out.println(refVar.toString());
}
catch (NullPointerException ex) {
  System.out.println("refVar is null");
}
```

is better to be replaced by

```java
if (refVar != null)
  System.out.println(refVar.toString());
else
  System.out.println("refVar is null");
```

### Defining Custom Exception Classes

- Use the exception classes in the API whenever possible.
- Define custom exception classes if the predefined classes are not sufficient.
- Define custom exception classes by extending Exception or a subclass of
  Exception.


Examples:

```java
public class InvalidRadiusException extends Exception {
  private double radius;

  /** Construct an exception */
  public InvalidRadiusException(double radius) {
    super("Invalid radius " + radius);
    this.radius = radius;
  }

  /** Return the radius */
  public double getRadius() {
    return radius;
  }
}
```

```java
public class CircleWithRadiusException {
  /** The radius of the circle */
  private double radius;

  /** The number of the objects created */
  private static int numberOfObjects = 0;

  /** Construct a circle with radius 1 */
  public CircleWithRadiusException() {
    this(1.0);
  }

  /** Construct a circle with a specified radius */
  public CircleWithRadiusException(double newRadius) {
    try {
      setRadius(newRadius);
      numberOfObjects++;
    }
    catch (InvalidRadiusException ex) {
      ex.printStackTrace();
    }
  }

  /** Return radius */
  public double getRadius() {
    return radius;
  }

  /** Set a new radius */
  public void setRadius(double newRadius)
      throws InvalidRadiusException {
    if (newRadius >= 0)
      radius =  newRadius;
    else
      throw new InvalidRadiusException(newRadius);
  }

  /** Return numberOfObjects */
  public static int getNumberOfObjects() {
    return numberOfObjects;
  }

  /** Return the area of this circle */
  public double findArea() {
    return radius * radius * 3.14159;
  }
}
```

```java
public class TestCircleWithRadiusException {
  /** Main method */
  public static void main(String[] args) {
    try {
      CircleWithRadiusException c1 = new CircleWithRadiusException(5);
      c1.setRadius(-5);
      CircleWithRadiusException c3 = new CircleWithRadiusException(0);
    }
    catch (InvalidRadiusException ex) {
      System.out.println(ex);
    }

    System.out.println("Number of objects created: " +
      CircleWithRadiusException.getNumberOfObjects());
  }
}
```

### Assertions

An assertion is a Java statement that enables you to assert an assumption about
your program. An assertion contains a Boolean expression that should be true
during program execution. Assertions can be used to assure program correctness
and avoid logic errors.


An assertion is declared using the new Java keyword `assert` in JDK 1.4 as
follows:

```java
assert assertion; or
assert assertion : detailMessage;
```

where `assertion` is a Boolean expression and `detailMessage` is a
primitive-type or an Object value.

#### Executing Assertions

When an assertion statement is executed, Java evaluates the assertion. If it is
`false`, an `AssertionError` will be thrown. The `AssertionError` class has a
no-arg constructor and seven overloaded single-argument constructors of type
`int`, `long`, `float`, `double`, `boolean`, `char`, and `Object`.

For the first assert statement with no detail message, the no-arg constructor of
`AssertionError` is used. For the second assert statement with a detail message,
an appropriate `AssertionError` constructor is used to match the data type of
the message. Since `AssertionError` is a subclass of `Error`, when an assertion
becomes `false`, the program displays a message on the console and exits.

Example:

```java
public class AssertionDemo {
  public static void main(String[] args) {
    int i; int sum = 0;
    for (i = 0; i < 10; i++) {
      sum += i;
    }
    assert i == 10;
    assert sum > 10 && sum < 5 * 10 : "sum is " + sum;
  }
}
```

#### Running Programs with Assertions

By default, the assertions are disabled at runtime. To enable it, use the switch
`–enableassertions`, or `–ea` for short, as follows:

```java
java –ea AssertionDemo
```

Assertions can be selectively enabled or disabled at class level or package
level. The disable switch is `–disableassertions` or `–da` for short. For example,
the following command enables assertions in package package1 and disables
assertions in class Class1.

```java
java –ea:package1 –da:Class1 AssertionDemo
```

#### Using Exception Handing or Assertions

Assertion should not be used to replace exception handling. Exception handling
deals with unusual circumstances during program execution. Assertions are to
assure the correctness of the program. Exception handling addresses robustness
and assertion addresses correctness. Like exception handling, assertions are not
used for normal tests, but for internal consistency and validity checks.
Assertions are checked at runtime and can be turned on or off at startup time.

_Do not use assertions for argument checking in public methods_. Valid arguments
that may be passed to a public method are considered to be part of the method’s
contract. The contract must always be obeyed whether assertions are enabled or
disabled. For example, the following code in the Circle class should be
rewritten using exception handling.

```java
public void setRadius(double newRadius) {
  assert newRadius >= 0;
  radius =  newRadius;
}
```

_Use assertions to reaffirm assumptions_. This gives you more confidence to assure
correctness of the program. A common use of assertions is to replace assumptions
with assertions in the code.

Another good use of assertions is place assertions in a switch statement without
a default case. For example,

```java
switch (month) {
  case 1: ... ; break;
  case 2: ... ; break;
  ...
  case 12: ... ; break;
  default: assert false : "Invalid month: " + month
}
```


## 7.1 Objects: Introduction

### Abstraction or Information hiding

**Abstraction** means to have a user interact with an item at a high-level, with
lower-level internal details hidden from the user (aka information hiding or
encapsulation).

<a name="abstract-data-type-term">**Abstract data type (ADT)**</a>

  - is a data type whose creation and update are constrained to specific
    well-defined operations. A class can be used to implement an ADT.


## 7.3 Defining a class

<a name="private-fields-term">**Private fields**</a>

  - Variables that member methods can access but class user cannot.


> A class' fields and methods are collectively called **class members**.

The programmer defines the details of each member method, sometimes called the
class' **implementation**. A **method definition** provides an access modifier,
return type, name, arguments, and the method's statements. A member method can
access all private fields.


## 7.4 Mutators, Accessors, and Private Helpers

### Mutators and accessors

A class' public methods are commonly classified as either mutators or accessors.

  - A **mutator** method may modify ("mutate") a class' fields.
  - An **accessor** method accesses fields but may not modify a class' fields.

Commonly, a field has two associated methods: a mutator for setting the value,
and an accessor for getting the value, known as a **setter** and **getter**
method, respectively, and typically with names starting with set or get. Other
mutators and accessors may exist that aren't associated with just one field,
such as the `print()` method below.


## 7.5 Initialization and Constructors

A **good practice** is to initialize all variables when declared. This section
deals with initializing the fields of a class when a variable of the class type
is allocated.

If a class does not have a programmer-defined constructor, then the Java
compiler implicitly defines a default constructor with no arguments. The Java
compiler also initializes all fields to their default values. Good practice is
to explicitly define a default constructor or use field initialization to
initialize all fields.

**Field initialization is usually preferred over using a constructor**. However,
sometimes initializations are more complicated, in which case a constructor is
needed.


## 7.6 Choosing Classes to Create

### Decomposing Into Classes

Creating a program may start by a programmer deciding what "things" exist, and
what each thing contains and does.

## 7.7 Defining main() in a Programmer-Defined Class

The `main()` method can be defined within a programmer-defined class and create
objects of that class type.

`main()` is a static method, which means `main()` does not have direct access to
the class' instance members. A programmer must create objects within `main()` to
call instance methods.

## Unit testing (classes)

### Testbenches

<a name="testbenches-term">**Testbenches**</a>

  - Like a chef who tastes food before serving, a class creator should test a
    class before allowing use. A **testbench** is a program whose job is to
    thoroughly test another program (or portion) via a series of input/output
    checks known as **test cases**.


<a name="unit-testing-term">**Unit testing**</a>

  - means to create and run a testbench for a specific item (or "unit") like a
    method or a class.


Features of a good testbench include:

  - Automatic checks. Ex: Values are compared, as in testData.GetNum1() != 100.
    For conciseness, only fails are printed.
  - Independent test cases. Ex: The test case for GetAverage() assigns new
    values, vs. relying on earlier values.
  - 100% code coverage: Every line of code is executed. A good testbench would
    have more test cases than below.
  - Includes not just typical values but also border cases: Unus


### Regression Testing

<a name="regression-testing-term">**Regression testing**</a>

  - means to retest an item like a class anytime that item is changed; if
    previously-passed test cases fail, the item has "regressed".

A testbench should be maintained along with the item, to always be usable for
regression testing.

Testbenches may be complex, with thousands of test cases. Various tools support
testing, and companies employ test engineers who only test other programmers'
items. A large percent, like 50% or more, of commercial software development
time may go into testing.

### Erroneous Unit Tests

An erroneous unit test may fail even if the code being tested is correct. A
common error is for a programmer to assume that a failing unit test means that
the code being tested has a bug. Such an assumption may lead the programmer to
spend time trying to "fix" code that is already correct. Good practice is to
inspect the code of a failing unit test before making changes to the code being
tested.

> [JUnit](https://junit.org/junit5/) testing framework for Java.


## 7.10 Objects and References

### References

A **reference** is a variable type that refers to an object. A reference may be
thought of as storing the memory address of an object. Variables of a class data
type (and array types, discussed elsewhere) are reference variables.

> Java does not provide a direct way to determine the memory location of an
object, or to determine the exact address to which a reference variable refers.
The "value" of a reference variable is unknown to the programmer.


## 7.11 The 'this' Implicit Parameter

<a name="implicit-parameter-term">**Implicit parameter**</a>

  - An object's member method is called using the syntax known as an **implicit
    parameter** of the member method because the compiler
    `objectReference.method()`. The object reference before the method name is
    converts the call syntax objectReference.method(...) into a method call with
    the object reference implicitly passed as a parameter. Ex:
    method(objectReference, ...).
  - Within a member method, the implicitly-passed object reference is accessible
    via the keyword `this`. In particular, a class member can be accessed as
    this.classMember. The "." is the member access operator.
  - Using this makes clear that a class member is being accessed and is
    essential if a field member and parameter have the same identifier. In the
    example below, this is necessary to differentiate between the field member
    sideLength and the parameter sideLength.


## 7.12 Primitive and Reference Types

### Wrapper classes

Java variables are one of two types.

    - A primitive type variable directly stores the data for that variable type,
      such as int, double, or char. Ex: int numStudents = 20; declares an int
      that directly stores the data 20.
    - A reference type variable can refer to an instance of a class, also known
      as an object.


Commonly used wrapper classes

| Reference type | Associated primitive type |
|----------------|---------------------------|
| Character      | char                      |
| Integer        | int                       |
| Double         | double                    |
| Boolean        | boolean                   |
| Long           | long                      |

A wrapper class object (as well as a String object) is **immutable**, meaning a
programmer cannot change the object via methods or variable assignments after
object creation. When the result of an expression is assigned to an Integer
reference variable, memory for a new Integer object with the computed value is
allocated, and the reference (or address) of this new object is assigned to the
reference variable. A new memory allocation occurs every time a new value is
assigned to an `Integer` variable, and the previous memory location to which the
variable referred, remains unmodified.

### Limits on Initialization Values

When using a literal for initialization, the programmer must ensure that the
literal's value falls within the appropriate numeric range, e.g., -2,147,483,648
to 2,147,483,647 for an integer. The wrapper classes (except for Character and
Boolean) declare the `MAX_VALUE` and `MIN_VALUE` fields, which are static fields
initialized with the maximum and minimum values a type may represent,
respectively. A programmer may access these fields to check the supported
numeric range by typing the wrapper class' name followed by a dot and the field
name, as in `Integer.MIN_VALUE`, which returns -2,147,483,648.

### Comparing Wrapper Class Objects

For reference variables of wrapper classes (e.g., Integer, Double, Boolean), a
common error is to use the equality operators == and != when comparing values,
which does not work as expected. Using the equality operators on any two
reference variables evaluates to either true or false depending on each
operand's referenced object. For example, given two Integers num1 and num2, the
expression num1 == num2 compares if both num1 and num2 reference the same
Integer object, but does not compare the Integers' contents. Because those
references will (usually) be different, num1 == num2 will evaluate to false.
This is not a syntax error, but clearly a logic error.

Although a programmer should never compare two reference variables of wrapper
classes using the equality operators, a programmer may use the equality
operators when comparing a wrapper class object with a primitive variable or a
literal constant. The relational operators <, <=, >, and >= may be used to
compare wrapper class objects. However, note that relational operators are not
typically valid for other reference types. The following table summarizes
allowable comparisons.


| `objectVar == objectVar`    | DO NOT USE. Compares references to objects, not the value of the objects |
|-----------------------------|--------------------------------------------------------------------------|
| `objectVar == primitiveVar` | OK. Compares value of object to value of primitive variable.             |
| `objectVar == 100`          | OK. Compares value of objects to literal constant.                       |
| `objectVar < objectVar`     | OK. Compares values of objects.                                          |
| `objectVar < primitiveVar`  | OK. Compares values of object to value of primitive.                     |
| `objectVar < 100`          | OK. Compares values of object to literal constant.                       |

Reference variables of wrapper classes can also be compared using the `equals()`
and `compareTo()` methods. These method descriptions are presented for the
Integer class, but apply equally well to the other wrapper classes. Although the
use of comparison methods is slightly cumbersome in comparison to relational
operators, **these comparison methods may be preferred by programmers who do not
wish to memorize exactly which comparison operators work as expected.**

`equals(otherInt)`

  - true if both Integers contain the same value. otherInteger may be an Integer
    object, int variable, or integer literal.


```java
num1.equals(num2) // Evaluates to false
num1.equals(10)   // Evaluates to true
!(num2.equals(regularInt)) // Evaluates to true because 8 != 20
```

`compareTo(otherInt)`

  - return 0 if the two Integer values are equal, returns a negative number if
    the Integer value is less than otherInteger's value, and returns a positive
    number if the Integer value is greater than otherInteger's value.
    otherInteger may be an Integer object, int variable, or integer literal.


```java
num1.compareTo(num2) // Returns value greater than 0, because 10 > 8
num2.compareTo(8)    // Returns 0 because 8 == 8
num1.compareTo(regularInt)   // Returns value less than 0, because 10 < 20
```

> Other workaround with `objectVar` to `objectVar` `==` or `=!` comparison is to
assign one `objectVar` to an instance of a primitive counterpart before the
comparison.


## 7.17 Java Documentation for Classes

The **Javadoc** tool parses source code along with specially formatted comments
to generate documentation. The documentation generated by Javadoc is known as an
**API** for classes and class members. API is short for **application
programming interface**.

The specially formatted comments for Javadoc are called Doc comments, which are
multi-line comments consisting of all text enclosed between the `/**` and `*/`
characters. Importantly, Doc comments are distinguished by the opening
characters `/**,` which include two asterisks.

### Common Block Tags Used in Javadoc Comments

| Block tag  | Compatibility         | Description                                                  |
|------------|-----------------------|--------------------------------------------------------------|
| `@author`  | classes               | Used to specify an author.                                   |
| `@version` | classes               | Used to specify a version number.                            |
| `@param`   | methods, constructors | Used to describe a parameter.                                |
| `@return`  | methods               | Used to describe the value or object returned by the method. |
| `@see`     | all                   | Used to refer reder to relevant websites or class memebers.  |

The block tag specification below creates a reference to ElapsedTime's
`printTime()` method.

```java
@see ElapsedTime#printTime()
```

Private class members are not included by default in the API documentation
generated by the Javadoc tool. API documentation is meant to provide a summary
of all functionality available to external applications interfacing with the
described classes. Thus, private class members, which cannot be accessed by
other classes, are not typically included in the documentation. The Java Scanner
class specification, for example, only describes the public class members
available to programmers using the class.

Similarly, the resulting API documentation for the above classes need only
include information that enables their use by other programmers. However, if a
programmer needs to document a class's complete structure, the Javadoc tool can
be executed with the `-private` flag, as in `javadoc -private -d destination
class1.java class2.java`, to enable the documentation of private class members.


## 7.18 Parameters of Reference Types

A **reference variable** is a variable that points to, or refers to, an object
or array. Internally, a reference variable stores a reference, or the memory
location, of the object to which it refers. A programmer can only access the
data or functionality provided by objects through the use of reference
variables. Because reference variables store object locations and not the object
data itself, passing a reference variable as a method argument assigns the
argument's stored reference to the corresponding method parameter. Similarly,
returning a reference variable returns an object reference.


## 7.19 Static fields and methods

### Static fields

The keyword **static** indicates a variable is allocated in memory only once during
a program's execution. Static variables reside in the program's static memory
region and have a global scope. Thus, static variables can be accessed from
anywhere in a program.

In a class, a **static field** is a field of the class instead of a field of each
class object. Thus, static fields are independent of any class object, and can
be accessed without creating a class object. Static fields are declared and
initialized in the class definition. Within a class method, a static field is
accessed using the field name. A public static field can be accessed outside the
class using dot notation: `ClassName.fieldName`.

> Static fields are also called **class variables**, and non-static fields are
also called **instance variables**.

### Static Member Methods

A **static member method** is a class method that is independent of class
objects.  Static member methods are typically used to access and mutate private
static fields from outside the class. Since static methods are independent of
class objects, the this parameter is not passed to a static member method. So, a
_static member method can only access a class' static fields_.


## 7.20 Using Packages

### Built-in Java Packages

<a name="package-term">**Package**</a>

  -  a grouping of related types, classes, interfaces, and subpackage. The
     types, classes, and interfaces in a package are called **package members**.
     The following table lists several built-in Java packages and sample package
     members.


### Using Package Members in a Program

A programmer can use a package member using one of the following methods.

- Using a package member's fully qualified name: A class' **fully qualified
  name** is the concatenation of the package name with the class name using a
  period.  Ex: java.util.Scanner is the fully qualified name for the Scanner
  class in the java.util package.
- Using an import statement to import the package member: An **import
  statement** imports a package member into a file to enable use of the package
  member directly, without having to use the package member's fully qualified
  name. Ex: import java.util.Scanner; imports the Scanner class into a file and
  allows a programmer to use Scanner instead of java.util.Scanner.
- Using an import statement to import every member in a package: A programmer
  import all members of a package by using the **wildcard** character * instead
  of a package member name. Ex: import java.util.*; imports all classes in the
  java.util package and allows a programmer use package members such as Scanner
  and ArrayList directly.


## 10.2 Access by Members of Derived Classes

| Specifier    | Description                                                                 |
|--------------|-----------------------------------------------------------------------------|
| `private`    | Accessible by self.                                                         |
| `protected`  | Accessible by self, derived classes, and other classes in the same package. |
| `public`     | Accessible by self, derive classed and everyone else.                       |
| no specifier | Accessible by self and other classes in the same package.                   |

### Class definitions

Separately, the keyword "public" in a class definition like public class
DerivedClass {...} specifies a class's visibility in other classes in the
program:

- _public_ : A class can be used by every class in the program regardless of the
  package in which either is defined.
- `no specifier` : A class can be used only in other classes within the same
  package, known as **package-private**.


## 10.3 Overriding Member Methods

### Overriding

When a derived class defines a member method that has the same name, parameters,
and return type as a base class's method, the member method is said to
**override** the base class's method.

The `@Override` annotation is placed above a method that overrides a base class
method so the compiler verifies that an identical base class method exists. An
**annotation** is an optional command beginning with the "@" symbol that can
provide the compiler with information that helps the compiler detect errors
better. The `@Override` annotation causes the compiler to produce an error when
a programmer mistakenly specifies parameters that are different from the
parameters of the method that should be overridden or misnames the overriding
method. Good practice is to always include an `@Override` annotation with a
method that is meant to override a base class method.

### Calling a base class method

An overriding method can call the overridden method by using the super keyword.
Ex: `super.getDescription` The **super** keyword is a reference variable used to
call the parent class's methods or constructors.

```java
public class Restaurant extends Business{
   ...

   @Override
   public String getDescription() {
      return super.getDescription() + "\n  Rating: " + rating;
   }

   ...
}
```

> A common error is to leave off super when wanting to call a base class method.
Without the use of the super keyword, the call to getDescription() refers to
itself (a recursive call), so getDescription() would call itself, which would
call itself, etc., never actually printing anything.

## 10.5 Polymorphism

<a name="polymorphism-term">**Polymorphism**</a>

  - refers to determining which program behavior to execute depending on data
    types.
  - Method overloading is a form of **compile-time polymorphism** wherein the
    compiler determines which of several identically-named methods to call based
    on the method's arguments.
  - Another form is **runtime polymorphism** wherein the compiler cannot make
    the determination but instead the determination is made while the program is
    running.


One scenario requiring runtime polymorphism involves derived classes.
Programmers commonly create a collection of objects of both base and derived
class types. Ex: the statement `ArrayList<GenericItem> inventoryList = new
ArrayList<GenericItem>();` declares an ArrayList that can contain references to
objects of type `GenericItem` or ProduceItem. ProduceItem derives from
GenericItem.


## ArrayLists of Objects

Because all classes are derived from the Object class, programmers can take
advantage of runtime polymorphism in order to create a collection (e.g.,
ArrayList) of objects of various class types and perform operations on the
elements. The program below uses the Business class and other built-in classes
to create and output a single ArrayList of differing types.

```java
import java.util.ArrayList;

public class ArrayListPrinter {

   // Method prints an ArrayList of Objects
   public static void PrintArrayList(ArrayList<Object> objList) {
      int i;

      for (i = 0; i < objList.size(); ++i) {
         System.out.println(objList.get(i));
      }
   }

   public static void main(String[] args) {
      ArrayList<Object> objList = new ArrayList<Object>();

      // Add new instances of various classes to objList
      objList.add(new Object());
      objList.add(12);
      objList.add(3.14);
      objList.add(new String("Hello!"));
      objList.add(new Business("ACME", "5 Main St"));

      // Print list of Objects
      PrintArrayList(objList);
   }
```

Note that a method operating on a collection of Object elements may only invoke
the methods defined by the base class (e.g., the Object class). Thus, a
statement that calls the `toString()` method on an element of an ArrayList of
Objects called objList, such as `objList.get(i).toString()`, is valid because
the Object class defines the `toString()` method. However, a statement that
calls, for example, the Integer class's `intValue()` method on the same element
(i.e., `objList.get(i).intValue()`) results in a compiler error even if that
particular element is an Integer object.


## 10.7 Abstract classes: Introduction (generic)

  - **Classes**: A class encapsulates data and behavior to create objects.
  - **Inheritance**: Inheritance allows one class (a subclass) to be based on
    another class (a base class or superclass). Ex: A Shape class may
    encapsulate data and behavior for geometric shapes, like setting/getting the
    Shape's name and color, while a Circle class may be a subclass of a Shape,
    with additional features like setting/getting the center point and radius.
  - **Abstract classes**: An abstract class is a class that guides the design of
    subclasses but cannot itself be instantiated as an object. Ex: An abstract
    Shape class might also specify that any subclass must define a computeArea()
    method.


## 10.8 Abstract classes

### Abstract and concrete classes

An **abstract method** is a method that is not implemented in the base class,
thus all derived classes must override the function. An abstract method is
denoted by the keyword abstract in front of the method signature. A **method
signature** defines the method's name and parameters. Ex: abstract double
computeArea(); declares an abstract method named computeArea().

An **abstract class** is a class that cannot be instantiated as an object, but
is the superclass for a subclass and specifies how the subclass must be
implemented. An abstract class is denoted by the keyword abstract in front of
the class definition. Any class with one or more abstract methods must be
abstract.

A **concrete class** is a class that is not abstract, and hence can be
instantiated.


## 10.9 Is-a versus has-a relationships

The 'has-a' relationship. A MotherInfo object 'has a' String object and 'has a'
ArrayList of ChildInfo objects, but no inheritance is involved.

```java
public class ChildInfo {
   public String firstName;
   public String birthDate;
   public String schoolName;

   ...
}

public class MotherInfo {
   public String firstName;
   public String birthDate;
   public String spouseName;
   public ArrayList<ChildInfo> childrenData;

   ...
}
```

The 'is-a' relationship. A MotherInfo object 'is a' kind of PersonInfo. The
MotherInfo class thus inherits from the PersonInfo class. Likewise for the
ChildInfo class.

```java
public class PersonInfo {
   public String firstName;
   public String birthdate;

   ...
}

public class ChildInfo extends PersonInfo {
   public String schoolName;

   ...
}

public class MotherInfo extends PersonInfo {
   public String spousename;
   public ArrayList<ChildInfo> childrenData;
  ...
}
```


## 10.10 UML

### UML class diagrams

The **Universal Modeling Language (UML)** is a language for software design that
uses different types of diagrams to visualize the structure and behavior of
programs. A **structural diagram** visualizes static elements of software, such
as the variables and methods used in the program. A **behavioral diagram**
visualizes dynamic behavior of software, such as the flow of an algorithm.

A UML **class diagram** is a structural diagram that can be used to visually model
the classes of a computer program, including member variables and methods.

### UML for inheritance

UML uses an arrow with a solid line and an unfilled arrow head to indicate that
one class inherits from another. The arrow points toward the superclass.

UML uses italics to denote abstract classes. In particular, UML uses italics for
the abstract class' name, and for each abstract method in the class. As a
reminder, a superclass does not have to be abstract. Also, any class with an
abstract method must be abstract.

## 10.11 Interfaces

Java provides **interfaces** as another mechanism for programmers to state that
a class adheres to rules defined by the interface. An **interface** can specify
a set of abstract methods that an implementing class must override and define.
In an interface, an abstract method does not need the abstract keyword in front
of the method signature.

To create an interface, a programmer uses the keyword interface. The following
code illustrates two interfaces named Drawable and DrawableASCII.

```java
import java.awt.Graphics2D;

public interface Drawable {
   public void draw(Graphics2D graphicsObject);
}
```

```java
public interface DrawableASCII {
   public void drawASCII(char drawChar);
}
```

Any class that implements an interface must:

  - List the interface name after the keyword implements
  - Override and implement the interface's abstract methods

Although inheritance and polymorphism allow a class to override methods defined
in the superclass, a class can only inherit from a single superclass. A class
can implement multiple interfaces using a comma separated list. Each Interface a
class implements means the class will adhere to the rules defined by the
interface.

```java
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;

public class Square implements Drawable, DrawableASCII {
   private int sideLength;

   public Square(int sideLength) {
      this.sideLength = sideLength;
   }

   @Override
   public void draw(Graphics2D graphicsObject) {
      Rectangle shapeObject = new Rectangle(0, 0, this.sideLength, this.sideLength);
      Color colorObject = new Color(255, 0, 0);
      graphicsObject.setColor(colorObject);
      graphicsObject.fill(shapeObject);
   }

   @Override
   public void drawASCII(char drawChar) {
      int rowIndex;
      int columnIndex;

      for (rowIndex = 0; rowIndex < this.sideLength; ++rowIndex) {
         for (columnIndex = 0; columnIndex < this.sideLength; ++columnIndex) {
            System.out.print("*");
         }
         System.out.println();
      }
   }
}
```

> UML Diagrams denote interfaces using the keyword interface, inside double angle
brackets, above the class name. Classes that implement the interface have a
dashed line with an unfilled arrow pointing at the interface. Following UML
conventions is important for clear communication between programmers.


<br>

# Resources

  - [Unified Modeling Language (UML)](https://www.cs.bsu.edu/homepages/pvgestwicki/misc/uml/)
  - [*Objects and Classes](file:../../../../../../files/summer-2020/CISC-191/week-2/objects_and_classes.ppt)
  - [*Object-Oriented Thinking](file:../../../../../../files/summer-2020/CISC-191/week-2/object-oriented_thinking.ppt)
  - [*Inheritance and Polymorphism](file:../../../../../../files/summer-2020/CISC-191/week-2/inheritance_and_polymorphism.ppt)
  - [*Exceptions Handling](file:../../../../../../files/summer-2020/CISC-191/week-2/exceptions_handling.ppt)

