---
title: Week 2
author: Mark Lucernas
date: 2020-06-23
summary: Object Oriented Programming
---


# Week 2: Object Oriented Programming

## UML

  - [Unified Modeling Language (UML)](https://www.cs.bsu.edu/homepages/pvgestwicki/misc/uml/)

### Sign Indicators

  - `+`          = indicates public modifier
  - `-`          = indicates private modifier
  - `underlined` = indicates static visibility


## Objects and Classes

  - [Objects and Classes](file:../../../../files/summer-2020/CISC-191/week-2/objects_and_classes.ppt)


Object-oriented programming (OOP) involves programming using objects. An object
represents an entity in the real world that can be distinctly identified. For
example, a student, a desk, a circle, a button, and even a loan can all be
viewed as objects. An object has a unique identity, state, and behaviors. The
state of an object consists of a set of data fields (also known as properties)
with their current values. The behavior of an object is defined by a set of
methods.

<a name="static-variables-constants-and-methods-term">**Static variables, constants, and methods**</a>

  - Static variables are shared by all the instances of the class.
  - Static methods are not tied to a specific object.
  - Static constants are final variables shared by all the instances of the
    class.


<a name="visibility-modifiers-term">**Visibility modifiers**</a>

  - _public_
    * The class, data, or method is visible to any class in any package.
  - _private_
    * The data or methods can be accessed only by the declaring class.
  - The private modifier restricts access to within a class, the default
    modifier restricts access to within a package, and the public modifier
    enables unrestricted access.


<a name="immutable-term">**Immutable**</a>

  - If the contents of an object cannot be changed once the object is created,
    the object is called an _immutable_ object and its class is called an
    _immutable_ class.
  - For a class to be immutable, it must mark all data fields private and
    provide no _mutator_ methods (getters) and no _accessor_ methods (setters)
    that would return a reference to a mutable data field object.


### Modifier Scope

private   = class
Default   = class, package
protected = class, package, subclass
public    = class, package, subclass, outside package


## Object-Oriented Thinking

  - [Object-Oriented Thinking](file:../../../../files/summer-2020/CISC-191/week-2/object-oriented_thinking.ppt)


<a name="class-abstraction-and-encapsulation-term">**Class abstraction and encapsulation**</a>

  - Class abstraction means to separate class implementation from the use of the
    class. The creator of the class provides a description of the class and let
    the user know how the class can be used. The user of the class does not need
    to know how the class is implemented. The detail of implementation is
    encapsulated and hidden from the user.


<a name="object-composition-term">**Object composition**</a>

  - Composition is actually a special case of the aggregation relationship.
    Aggregation models has-a relationships and represents an ownership
    relationship between two objects. The owner object is called an
    _aggregating_ object and its class an _aggregating_ class. The subject
    object is called an _aggregated_ object and its class an _aggregated_ class.


### Wrapper Classes

The wrapper classes do not have no-arg constructors. (2) The instances of all
wrapper classes are immutable, i.e., their internal values cannot be changed
once the objects are created.

  - `Boolean`
  - `Character`
  - `Short`
  - `Byte`
  - `Integer`
  - `Long`
  - `Float`
  - `Double`


#### Numeric Wrapper Class Constructors

You can construct a wrapper object either from a primitive data type value or
from a string representing the numeric value. The constructors for Integer and
Double are:

```java
public Integer(int value)
public Integer(String s)
public Double(double value)
public Double(String s)
```

Each numerical wrapper class has the constants MAX_VALUE and MIN_VALUE.
MAX_VALUE represents the maximum value of the corresponding primitive data type.
For Byte, Short, Integer, and Long, MIN_VALUE represents the minimum byte,
short, int, and long values. For Float and Double, MIN_VALUE represents the
minimum positive float and double values. The following statements display the
maximum integer (2,147,483,647), the minimum positive float (1.4E-45), and the
maximum double floating-point number (1.79769313486231570e+308d).

#### Conversion Methods

Each numeric wrapper class implements the abstract methods doubleValue,
floatValue, intValue, longValue, and shortValue, which are defined in the Number
class. These methods “convert” objects into primitive type values.


### The String Class

A String object is immutable; its contents cannot be changed.

#### Interned Strings

Since strings are immutable and are frequently used, to improve efficiency and
save memory, the JVM uses a unique instance for string literals with the same
character sequence. Such an instance is called interned.

> A new object is created if you use the new operator.  If you use the string
initializer, no new object is created if the interned object is already created.

#### StringBuilder and StringBuffer

The `StringBuilder`/`StringBuffer` class is an alternative to the String class.
In general, a `StringBuilder`/`StringBuffer` can be used wherever a string is
used.  `StringBuilder`/`StringBuffer` is more flexible than String. You can add,
insert, or append new contents into a string buffer, whereas the value of a
String object is fixed once the string is created.


### Regular Expressions

A regular expression (abbreviated regex) is a string that describes a pattern
for matching a set of strings. Regular expression is a powerful tool for string
manipulations. You can use regular expressions for matching, replacing, and
splitting strings.


## Inheritance and Polymorphism

  - [Inheritance and Polymorphism](file:../../../../files/summer-2020/CISC-191/week-2/inheritance_and_polymorphism.ppt)


### Superclasses and Subclasses

The keyword super refers to the superclass of the class in which super appears.
This keyword can be used in two ways:

  - To call a superclass constructor. `super()`
  - To call a superclass method. `super.methodName()`

#### Are Superclass’s Constructor Inherited?

No. They are not inherited. They are invoked explicitly or implicitly.

Explicitly using the super keyword.

  - A constructor is used to construct an instance of a class. Unlike properties
    and methods, a superclass's constructors are not inherited in the subclass.
    They can only be invoked from the subclasses' constructors, using the
    keyword _super_. If the keyword _super_ is not explicitly used, the
    superclass's no-arg constructor is automatically invoked.


#### Superclass’s Constructor Is Always Invoked

A constructor may invoke an overloaded constructor or its superclass’s
constructor. If none of them is invoked explicitly, the compiler puts super() as
the first statement in the constructor.

#### Overriding Methods in the Superclass

A subclass inherits methods from a superclass. Sometimes it is necessary for the
subclass to modify the implementation of a method defined in the superclass.
This is referred to as method overriding.

```java
public class Circle extends GeometricObject {
  // Other methods are omitted

  /** Override the toString method defined in GeometricObject */
  public String toString() {
    return super.toString() + "\nradius is " + radius;
  }
}
```

> An instance method can be overridden only if it is accessible. Thus a private
method cannot be overridden, because it is not accessible outside its own class.
If a method defined in a subclass is private in its superclass, the two methods
are completely unrelated.

> Like an instance method, a static method can be inherited. However, a static
method cannot be overridden. If a static method defined in the superclass is
redefined in a subclass, the method defined in the superclass is hidden.

### Polymorphism

_Polymorphism_ means that a variable of a supertype can refer to a subtype
object.

A class defines a type. A type defined by a subclass is called a subtype, and a
type defined by its superclass is called a supertype. Therefore, you can say
that Circle is a subtype of GeometricObject and GeometricObject is a supertype
for Circle.

```java
public class PolymorphismDemo {
  public static void main(String[] args) {
    m(new GraduateStudent());
    m(new Student());
    m(new Person());
    m(new Object());
  }
 
  public static void m(Object x) {
    System.out.println(x.toString());
  }
}
 
class GraduateStudent extends Student {
}
 
class Student extends Person {
  public String toString() {
    return "Student";
  }
}
 
class Person extends Object {
  public String toString() {
    return "Person";
  }
}
```

An object of a subtype can be used wherever its supertype value is required.
This feature is known as _polymorphism_.

When the method m(Object x) is executed, the argument x’s toString method is
invoked. x may be an instance of GraduateStudent, Student, Person, or Object.
Classes GraduateStudent, Student, Person, and Object have their own
implementation of the toString method. Which implementation is used will be
determined dynamically by the Java Virtual Machine at runtime. This capability
is known as dynamic binding.

Polymorphism allows methods to be used generically for a wide range of object
arguments. This is known as **generic programming**. If a method’s parameter
type is a superclass (e.g., Object), you may pass an object to this method of
any of the parameter’s subclasses (e.g., Student or String). When an object
(e.g., a Student object or a String object) is used in the method, the
particular implementation of the method of the object that is invoked (e.g.,
toString) is determined dynamically.

### Dynamic Binding

Dynamic binding works as follows: Suppose an object `o` is an instance of
classes $C_{1}$, $C_{2}$, ..., $C_{n-1}$, and $C_{n}$, where $C_{1}$ is a
subclass of $C_{2}$, $C_{2}$ is a subclass of $C_{3}$, ..., and $C_{n-1}$ is a
subclass of $C_{n}$. That is, $C_{n}$ is the most general class, and $C_{1}$ is
the most specific class. In Java, $C_{n}$ is the Object class. If `o` invokes a
method `p`, the JVM searches the implementation for the method `p` in $C_{1}$,
$C_{2}$, ..., $C_{n-1}$ and $C_{n}$, in this order, until it is found. Once an
implementation is found, the search stops and the first-found implementation is
invoked.

### Method Matching vs. Binding

Matching a method signature and binding a method implementation are two issues.
The compiler finds a matching method according to parameter type, number of
parameters, and order of the parameters at compilation time. A method may be
implemented in several subclasses. The Java Virtual Machine dynamically binds
the implementation of the method at runtime.

### Casting Objects

You have already used the casting operator to convert variables of one primitive
type to another. Casting can also be used to convert an object of one class type
to another within an inheritance hierarchy. In the preceding section, the
statement

```java
m(new Student());
```

assigns the object new Student() to a parameter of the Object type. This
statement is equivalent to:

```java
Object o = new Student(); // Implicit casting
m(o);
```

The statement Object o = new Student(), known as implicit casting, is legal
because an instance of Student is automatically an instance of Object.

### Why Casting Is Necessary?

Suppose you want to assign the object reference o to a variable of the Student
type using the following statement:

```java
Student b = o;
```

A compile error would occur. Why does the statement Object o = new Student()
work and the statement Student b = o doesn’t? This is because a Student object
is always an instance of Object, but an Object is not necessarily an instance of
Student. Even though you can see that o is really a Student object, the compiler
is not so clever to know it. To tell the compiler that o is a Student object,
use an explicit casting. The syntax is similar to the one used for casting among
primitive data types. Enclose the target object type in parentheses and place it
before the object to be cast, as follows:

```java
Student b = (Student)o; // Explicit casting
```

> Explicit casting must be used when casting an object from a superclass to a
subclass.  This type of casting may not always succeed.

### The instanceof Operator

Use the `instanceof` operator to test whether an object is an instance of a
class:

```java
Object myObject = new Circle();
... // Some lines of code
/** Perform casting if myObject is an instance of Circle */
if (myObject instanceof Circle) {
  System.out.println("The circle diameter is " +
    ((Circle)myObject).getDiameter());
  ...
}
```

### The equals Method

The `equals()` method compares the contents of two objects. The default
implementation of the equals method in the Object class is as follows:

```java
public boolean equals(Object o) {
  if (o instanceof Circle) {
    return radius == ((Circle)o).radius;
  }
  else
    return false;
}
```

> The == comparison operator is used for comparing two primitive data type
values or for determining whether two objects have the same references. The
equals method is intended to test whether two objects have the same contents,
provided that the method is modified in the defining class of the objects. The
== operator is stronger than the equals method, in that the == operator checks
whether the two reference variables refer to the same object.

### The ArrayList Class

You can create an array to store objects. But the array’s size is fixed once the
array is created. Java provides the ArrayList class that can be used to store an
unlimited number of objects.

`java.util.ArralyList<E>`

ArrayList is known as a generic class with a generic type `E`. You can specify a
concrete type to replace `E` when creating an `ArrayList`. For example, the
following statement creates an `ArrayList` and assigns its reference to variable
`cities`. This `ArrayList` object can be used to store strings.

```java
ArrayList<String> cities = new ArrayList<String>();
ArrayList<String> cities = new ArrayList<>();
```

#### Array Lists from/to Arrays

Creating an ArrayList from an array of objects:

```java
String[] array = {"red", "green", "blue"};
ArrayList<String> list = new ArrayList<>(Arrays.asList(array));
```

Creating an array of objects from an ArrayList:

```java
String[] array1 = new String[list.size()];
list.toArray(array1);
```

#### max and min in an Array List

```java
String[] array = {"red", "green", "blue"};
System.out.pritnln(java.util.Collections.max(
   new ArrayList<String>(Arrays.asList(array)));
```

```java
String[] array = {"red", "green", "blue"};
System.out.pritnln(java.util.Collections.min(
  new ArrayList<String>(Arrays.asList(array)));
```

#### Shuffling an Array List

```java
Integer[] array = {3, 5, 95, 4, 15, 34, 3, 6, 5};
ArrayList<Integer> list = new
  ArrayList<>(Arrays.asList(array));
java.util.Collections.shuffle(list);
System.out.println(list);
```

### The protected Modifier

  - The `protected` modifier can be applied on data and methods in a class. A
    protected data or a `protected` method in a public class can be accessed by
    any class in the same package or its subclasses, **even if the subclasses
    are in a different package**.

  - Visibility increases in this order:
    * private, default, protected, public


### A Subclass Cannot Weaken the Accessibility

A subclass may override a protected method in its superclass and change its
visibility to public. However, a subclass cannot weaken the accessibility of a
method defined in the superclass. For example, if a method is defined as public
in the superclass, it must be defined as public in the subclass.

> The modifiers are used on classes and class members (data and methods), except
that the final modifier can also be used on local variables in a method. A final
local variable is a constant inside a method.

### The final Modifier

  - The final class cannot be extended:

```java
final class Math {
  ...
}
```

  - The final variable is a constant:

```java
final static double PI = 3.14159;
```

  - The final method cannot be
    overridden by its subclasses.


## Exceptions Handling and Text IO

  - [Exceptions Handling](file:../../../../files/summer-2020/CISC-191/week-2/exceptions_handling.ppt)


### System Errors

System _errors_ are thrown by JVM and represented in the `Error` class. The
`Error` class describes internal system errors. Such errors rarely occur. If one
does, there is little you can do beyond notifying the user and trying to
terminate the program gracefully.

### Exceptions

_Exception_ describes errors caused by your program and external circumstances.
These errors can be caught and handled by your program.

### Runtime Exceptions

RuntimeException is caused by programming errors, such as bad casting, accessing
an out-of-bounds array, and numeric errors.

### Checked Exceptions vs. Unchecked Exceptions

`RuntimeException`, `Error` and their subclasses are known as _unchecked
exceptions_.  All other exceptions are known as _checked exceptions_, meaning
that the compiler forces the programmer to check and deal with the exceptions.

#### Unchecked Exceptions

In most cases, unchecked exceptions reflect programming logic errors that are
not recoverable. For example, a `NullPointerException` is thrown if you access
an object through a reference variable before an object is assigned to it; an
`IndexOutOfBoundsException` is thrown if you access an element in an array
outside the bounds of the array. These are the logic errors that should be
corrected in the program. Unchecked exceptions can occur anywhere in the
program. To avoid cumbersome overuse of try-catch blocks, Java does not mandate
you to write code to catch unchecked exceptions.

### Declaring Exceptions

Every method must state the types of checked exceptions it might throw. This is
known as _declaring exceptions_.

```java
public void myMethod() throws IOException
public void myMethod() throws IOException, OtherException
```

### Throwing Exceptions

When the program detects an error, the program can create an instance of an
appropriate exception type and throw it. This is known as throwing an exception.
Here is an example,

```java
throw new TheException();
TheException ex = new TheException();
throw ex;
```

Example

```java
/** Set a new radius */
public void setRadius(double newRadius) throws IllegalArgumentException {
  if (newRadius >= 0)
    radius =  newRadius;
  else
    throw new IllegalArgumentException("Radius cannot be negative");
}
```

### Catching Exceptions

```java
try {
  statements;  // Statements that may throw exceptions
}
catch (Exception1 exVar1) {
  handler for exception1;
}
catch (Exception2 exVar2) {
  handler for exception2;
}
...
catch (ExceptionN exVar3) {
  handler for exceptionN;
}
```

### Catch or Declare Checked Exceptions

Java forces you to deal with checked exceptions. If a method declares a checked
exception (i.e., an exception other than `Error` or `RuntimeException`), you must
invoke it in a try-catch block or declare to throw the exception in the calling
method.

### Rethrowing Exceptions

try {
  statements;
}
catch(TheException ex) {
  perform operations before exits;
  throw ex;
}

### The finally Clause

```java
try {
  statements;
}
catch(TheException ex) {
  handling ex;
}
finally {
  finalStatements;
}
```

### Cautions When Using Exceptions

Exception handling separates error-handling code from normal programming tasks,
thus making programs easier to read and to modify. Be aware, however, that
exception handling usually requires more time and resources because it requires
instantiating a new exception object, rolling back the call stack, and
propagating the errors to the calling methods.


### When to Throw Exceptions

An exception occurs in a method. If you want the exception to be processed by
its caller, you should create an exception object and throw it. If you can
handle the exception in the method where it occurs, there is no need to throw
it.

### When to Use Exceptions

When should you use the try-catch block in the code? You should use it to deal
with unexpected error conditions. Do not use it to deal with simple, expected
situations. For example, the following code

```java
try {
  System.out.println(refVar.toString());
}
catch (NullPointerException ex) {
  System.out.println("refVar is null");
}
```

is better to be replaced by

```java
if (refVar != null)
  System.out.println(refVar.toString());
else
  System.out.println("refVar is null");
```

### Defining Custom Exception Classes

- Use the exception classes in the API whenever possible.
- Define custom exception classes if the predefined classes are not sufficient.
- Define custom exception classes by extending Exception or a subclass of
  Exception.


Examples:

```java
public class InvalidRadiusException extends Exception {
  private double radius;

  /** Construct an exception */
  public InvalidRadiusException(double radius) {
    super("Invalid radius " + radius);
    this.radius = radius;
  }

  /** Return the radius */
  public double getRadius() {
    return radius;
  }
}
```

```java
public class CircleWithRadiusException {
  /** The radius of the circle */
  private double radius;

  /** The number of the objects created */
  private static int numberOfObjects = 0;

  /** Construct a circle with radius 1 */
  public CircleWithRadiusException() {
    this(1.0);
  }

  /** Construct a circle with a specified radius */
  public CircleWithRadiusException(double newRadius) {
    try {
      setRadius(newRadius);
      numberOfObjects++;
    }
    catch (InvalidRadiusException ex) {
      ex.printStackTrace();
    }
  }

  /** Return radius */
  public double getRadius() {
    return radius;
  }

  /** Set a new radius */
  public void setRadius(double newRadius)
      throws InvalidRadiusException {
    if (newRadius >= 0)
      radius =  newRadius;
    else
      throw new InvalidRadiusException(newRadius);
  }

  /** Return numberOfObjects */
  public static int getNumberOfObjects() {
    return numberOfObjects;
  }

  /** Return the area of this circle */
  public double findArea() {
    return radius * radius * 3.14159;
  }
}
```

```java
public class TestCircleWithRadiusException {
  /** Main method */
  public static void main(String[] args) {
    try {
      CircleWithRadiusException c1 = new CircleWithRadiusException(5);
      c1.setRadius(-5);
      CircleWithRadiusException c3 = new CircleWithRadiusException(0);
    }
    catch (InvalidRadiusException ex) {
      System.out.println(ex);
    }

    System.out.println("Number of objects created: " +
      CircleWithRadiusException.getNumberOfObjects());
  }
}
```

### Assertions

An assertion is a Java statement that enables you to assert an assumption about
your program. An assertion contains a Boolean expression that should be true
during program execution. Assertions can be used to assure program correctness
and avoid logic errors.


An assertion is declared using the new Java keyword `assert` in JDK 1.4 as
follows:

```java
assert assertion; or
assert assertion : detailMessage;
```

where `assertion` is a Boolean expression and `detailMessage` is a
primitive-type or an Object value.

#### Executing Assertions

When an assertion statement is executed, Java evaluates the assertion. If it is
`false`, an `AssertionError` will be thrown. The `AssertionError` class has a
no-arg constructor and seven overloaded single-argument constructors of type
`int`, `long`, `float`, `double`, `boolean`, `char`, and `Object`.

For the first assert statement with no detail message, the no-arg constructor of
`AssertionError` is used. For the second assert statement with a detail message,
an appropriate `AssertionError` constructor is used to match the data type of
the message. Since `AssertionError` is a subclass of `Error`, when an assertion
becomes `false`, the program displays a message on the console and exits.

Example:

```java
public class AssertionDemo {
  public static void main(String[] args) {
    int i; int sum = 0;
    for (i = 0; i < 10; i++) {
      sum += i;
    }
    assert i == 10;
    assert sum > 10 && sum < 5 * 10 : "sum is " + sum;
  }
}
```

#### Running Programs with Assertions

By default, the assertions are disabled at runtime. To enable it, use the switch
`–enableassertions`, or `–ea` for short, as follows:

```java
java –ea AssertionDemo
```

Assertions can be selectively enabled or disabled at class level or package
level. The disable switch is `–disableassertions` or `–da` for short. For example,
the following command enables assertions in package package1 and disables
assertions in class Class1.

```java
java –ea:package1 –da:Class1 AssertionDemo
```

#### Using Exception Handing or Assertions

Assertion should not be used to replace exception handling. Exception handling
deals with unusual circumstances during program execution. Assertions are to
assure the correctness of the program. Exception handling addresses robustness
and assertion addresses correctness. Like exception handling, assertions are not
used for normal tests, but for internal consistency and validity checks.
Assertions are checked at runtime and can be turned on or off at startup time.

_Do not use assertions for argument checking in public methods_. Valid arguments
that may be passed to a public method are considered to be part of the method’s
contract. The contract must always be obeyed whether assertions are enabled or
disabled. For example, the following code in the Circle class should be
rewritten using exception handling.

```java
public void setRadius(double newRadius) {
  assert newRadius >= 0;
  radius =  newRadius;
}
```

_Use assertions to reaffirm assumptions_. This gives you more confidence to assure
correctness of the program. A common use of assertions is to replace assumptions
with assertions in the code.

Another good use of assertions is place assertions in a switch statement without
a default case. For example,

```java
switch (month) {
  case 1: ... ; break;
  case 2: ... ; break;
  ...
  case 12: ... ; break;
  default: assert false : "Invalid month: " + month
}
```


## 7.1 Objects: Introduction

### Abstraction or Information hiding

**Abstraction** means to have a user interact with an item at a high-level, with
lower-level internal details hidden from the user (aka information hiding or
encapsulation).

<a name="abstract-data-type-term">**Abstract data type (ADT)**</a>

  - is a data type whose creation and update are constrained to specific
    well-defined operations. A class can be used to implement an ADT.


## 7.3 Defining a class

<a name="private-fields-term">**Private fields**</a>

  - Variables that member methods can access but class user cannot.


> A class' fields and methods are collectively called **class members**.

The programmer defines the details of each member method, sometimes called the
class' **implementation**. A **method definition** provides an access modifier,
return type, name, arguments, and the method's statements. A member method can
access all private fields.


## 7.4 Mutators, Accessors, and Private Helpers

### Mutators and accessors

A class' public methods are commonly classified as either mutators or accessors.

  - A **mutator** method may modify ("mutate") a class' fields.
  - An **accessor** method accesses fields but may not modify a class' fields.

Commonly, a field has two associated methods: a mutator for setting the value,
and an accessor for getting the value, known as a **setter** and **getter**
method, respectively, and typically with names starting with set or get. Other
mutators and accessors may exist that aren't associated with just one field,
such as the `print()` method below.


## 7.5 Initialization and Constructors

A **good practice** is to initialize all variables when declared. This section
deals with initializing the fields of a class when a variable of the class type
is allocated.

If a class does not have a programmer-defined constructor, then the Java
compiler implicitly defines a default constructor with no arguments. The Java
compiler also initializes all fields to their default values. Good practice is
to explicitly define a default constructor or use field initialization to
initialize all fields.

**Field initialization is usually preferred over using a constructor**. However,
sometimes initializations are more complicated, in which case a constructor is
needed.


## 7.6 Choosing Classes to Create

### Decomposing Into Classes

Creating a program may start by a programmer deciding what "things" exist, and
what each thing contains and does.

## 7.7 Defining main() in a Programmer-Defined Class

The `main()` method can be defined within a programmer-defined class and create
objects of that class type.

`main()` is a static method, which means `main()` does not have direct access to
the class' instance members. A programmer must create objects within `main()` to
call instance methods.

## Unit testing (classes)

### Testbenches

<a name="testbenches-term">**Testbenches**</a>

  - Like a chef who tastes food before serving, a class creator should test a
    class before allowing use. A **testbench** is a program whose job is to
    thoroughly test another program (or portion) via a series of input/output
    checks known as **test cases**.


<a name="unit-testing-term">**Unit testing**</a>

  - means to create and run a testbench for a specific item (or "unit") like a
    method or a class.


Features of a good testbench include:

  - Automatic checks. Ex: Values are compared, as in testData.GetNum1() != 100.
    For conciseness, only fails are printed.
  - Independent test cases. Ex: The test case for GetAverage() assigns new
    values, vs. relying on earlier values.
  - 100% code coverage: Every line of code is executed. A good testbench would
    have more test cases than below.
  - Includes not just typical values but also border cases: Unus


### Regression Testing

<a name="regression-testing-term">**Regression testing**</a>

  - means to retest an item like a class anytime that item is changed; if
    previously-passed test cases fail, the item has "regressed".

A testbench should be maintained along with the item, to always be usable for
regression testing.

Testbenches may be complex, with thousands of test cases. Various tools support
testing, and companies employ test engineers who only test other programmers'
items. A large percent, like 50% or more, of commercial software development
time may go into testing.

### Erroneous Unit Tests

An erroneous unit test may fail even if the code being tested is correct. A
common error is for a programmer to assume that a failing unit test means that
the code being tested has a bug. Such an assumption may lead the programmer to
spend time trying to "fix" code that is already correct. Good practice is to
inspect the code of a failing unit test before making changes to the code being
tested.

> [JUnit](https://junit.org/junit5/) testing framework for Java.


## 7.10 Objects and References

### References

A **reference** is a variable type that refers to an object. A reference may be
thought of as storing the memory address of an object. Variables of a class data
type (and array types, discussed elsewhere) are reference variables.

> Java does not provide a direct way to determine the memory location of an
object, or to determine the exact address to which a reference variable refers.
The "value" of a reference variable is unknown to the programmer.


## 7.11 The 'this' Implicit Parameter

<a name="implicit-parameter-term">**Implicit parameter**</a>

  - An object's member method is called using the syntax
    known as an **implicit parameter** of the member method because the compiler
    `objectReference.method()`. The object reference before the method name is
    converts the call syntax objectReference.method(...) into a method call with
    the object reference implicitly passed as a parameter. Ex:
    method(objectReference, ...).


<br>

# Resources

  - [Unified Modeling Language (UML)](https://www.cs.bsu.edu/homepages/pvgestwicki/misc/uml/)
  - [Objects and Classes](file:../../../../files/summer-2020/CISC-191/week-2/objects_and_classes.ppt)
  - [Object-Oriented Thinking](file:../../../../files/summer-2020/CISC-191/week-2/object-oriented_thinking.ppt)
  - [Inheritance and Polymorphism](file:../../../../files/summer-2020/CISC-191/week-2/inheritance_and_polymorphism.ppt)
  - [Exceptions Handling](file:../../../../files/summer-2020/CISC-191/week-2/exceptions_handling.ppt)
  - [Andrew Huang CISC 191: Intermediate Java Programming - zyBooks](https://www.zybooks.com/)
