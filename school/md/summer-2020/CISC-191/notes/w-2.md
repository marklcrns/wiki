---
title: Week 2
author: Mark Lucernas
date: 2020-06-23
summary: Object Oriented Programming
---


# Week 2: Object Oriented Programming

## UML

  - [Unified Modeling Language (UML)](https://www.cs.bsu.edu/homepages/pvgestwicki/misc/uml/)

### Sign Indicators

  - `+`          = indicates public modifier
  - `-`          = indicates private modifier
  - `underlined` = indicates static visibility


## Objects and Classes

  - [Objects and Classes](file:../../../../files/summer-2020/CISC-191/week-2/objects_and_classes.ppt)


Object-oriented programming (OOP) involves programming using objects. An object
represents an entity in the real world that can be distinctly identified. For
example, a student, a desk, a circle, a button, and even a loan can all be
viewed as objects. An object has a unique identity, state, and behaviors. The
state of an object consists of a set of data fields (also known as properties)
with their current values. The behavior of an object is defined by a set of
methods.

<a name="static-variables-constants-and-methods-term">**Static variables, constants, and methods**</a>

  - Static variables are shared by all the instances of the class.
  - Static methods are not tied to a specific object.
  - Static constants are final variables shared by all the instances of the
    class.


<a name="visibility-modifiers-term">**Visibility modifiers**</a>

  - _public_
    * The class, data, or method is visible to any class in any package.
  - _private_
    * The data or methods can be accessed only by the declaring class.
  - The private modifier restricts access to within a class, the default
    modifier restricts access to within a package, and the public modifier
    enables unrestricted access.


<a name="immutable-term">**Immutable**</a>

  - If the contents of an object cannot be changed once the object is created,
    the object is called an _immutable_ object and its class is called an
    _immutable_ class.
  - For a class to be immutable, it must mark all data fields private and
    provide no _mutator_ methods (getters) and no _accessor_ methods (setters)
    that would return a reference to a mutable data field object.


## Object-Oriented Thinking

  - [Object-Oriented Thinking](file:../../../../files/summer-2020/CISC-191/week-2/object-oriented_thinking.ppt)


<a name="class-abstraction-and-encapsulation-term">**Class abstraction and encapsulation**</a>

  - Class abstraction means to separate class implementation from the use of the
    class. The creator of the class provides a description of the class and let
    the user know how the class can be used. The user of the class does not need
    to know how the class is implemented. The detail of implementation is
    encapsulated and hidden from the user.


<a name="object-composition-term">**Object composition**</a>

  - Composition is actually a special case of the aggregation relationship.
    Aggregation models has-a relationships and represents an ownership
    relationship between two objects. The owner object is called an
    _aggregating_ object and its class an _aggregating_ class. The subject
    object is called an _aggregated_ object and its class an _aggregated_ class.


### Wrapper Classes

The wrapper classes do not have no-arg constructors. (2) The instances of all
wrapper classes are immutable, i.e., their internal values cannot be changed
once the objects are created.

  - `Boolean`
  - `Character`
  - `Short`
  - `Byte`
  - `Integer`
  - `Long`
  - `Float`
  - `Double`


#### Numeric Wrapper Class Constructors

You can construct a wrapper object either from a primitive data type value or
from a string representing the numeric value. The constructors for Integer and
Double are:

```java
public Integer(int value)
public Integer(String s)
public Double(double value)
public Double(String s)
```

Each numerical wrapper class has the constants MAX_VALUE and MIN_VALUE.
MAX_VALUE represents the maximum value of the corresponding primitive data type.
For Byte, Short, Integer, and Long, MIN_VALUE represents the minimum byte,
short, int, and long values. For Float and Double, MIN_VALUE represents the
minimum positive float and double values. The following statements display the
maximum integer (2,147,483,647), the minimum positive float (1.4E-45), and the
maximum double floating-point number (1.79769313486231570e+308d).

#### Conversion Methods

Each numeric wrapper class implements the abstract methods doubleValue,
floatValue, intValue, longValue, and shortValue, which are defined in the Number
class. These methods “convert” objects into primitive type values.


### The String Class

A String object is immutable; its contents cannot be changed.

#### Interned Strings

Since strings are immutable and are frequently used, to improve efficiency and
save memory, the JVM uses a unique instance for string literals with the same
character sequence. Such an instance is called interned.

> A new object is created if you use the new operator.  If you use the string
initializer, no new object is created if the interned object is already created.

#### StringBuilder and StringBuffer

The `StringBuilder`/`StringBuffer` class is an alternative to the String class.
In general, a `StringBuilder`/`StringBuffer` can be used wherever a string is
used.  `StringBuilder`/`StringBuffer` is more flexible than String. You can add,
insert, or append new contents into a string buffer, whereas the value of a
String object is fixed once the string is created.


### Regular Expressions

A regular expression (abbreviated regex) is a string that describes a pattern
for matching a set of strings. Regular expression is a powerful tool for string
manipulations. You can use regular expressions for matching, replacing, and
splitting strings.


## Inheritance and Polymorphism

  - [Inheritance and Polymorphism](file:../../../../files/summer-2020/CISC-191/week-2/inheritance_and_polymorphism.ppt)


### Superclasses and Subclasses

The keyword super refers to the superclass of the class in which super appears.
This keyword can be used in two ways:

  - To call a superclass constructor. `super()`
  - To call a superclass method. `super.methodName()`

#### Are Superclass’s Constructor Inherited?

No. They are not inherited. They are invoked explicitly or implicitly.

Explicitly using the super keyword.

  - A constructor is used to construct an instance of a class. Unlike properties
    and methods, a superclass's constructors are not inherited in the subclass.
    They can only be invoked from the subclasses' constructors, using the
    keyword _super_. If the keyword _super_ is not explicitly used, the
    superclass's no-arg constructor is automatically invoked.


#### Superclass’s Constructor Is Always Invoked

A constructor may invoke an overloaded constructor or its superclass’s
constructor. If none of them is invoked explicitly, the compiler puts super() as
the first statement in the constructor.

#### Overriding Methods in the Superclass

A subclass inherits methods from a superclass. Sometimes it is necessary for the
subclass to modify the implementation of a method defined in the superclass.
This is referred to as method overriding.

```java
public class Circle extends GeometricObject {
  // Other methods are omitted

  /** Override the toString method defined in GeometricObject */
  public String toString() {
    return super.toString() + "\nradius is " + radius;
  }
}
```

> An instance method can be overridden only if it is accessible. Thus a private
method cannot be overridden, because it is not accessible outside its own class.
If a method defined in a subclass is private in its superclass, the two methods
are completely unrelated.

> Like an instance method, a static method can be inherited. However, a static
method cannot be overridden. If a static method defined in the superclass is
redefined in a subclass, the method defined in the superclass is hidden.

### Polymorphism

_Polymorphism_ means that a variable of a supertype can refer to a subtype
object.

A class defines a type. A type defined by a subclass is called a subtype, and a
type defined by its superclass is called a supertype. Therefore, you can say
that Circle is a subtype of GeometricObject and GeometricObject is a supertype
for Circle.

```java
public class PolymorphismDemo {
  public static void main(String[] args) {
    m(new GraduateStudent());
    m(new Student());
    m(new Person());
    m(new Object());
  }
 
  public static void m(Object x) {
    System.out.println(x.toString());
  }
}
 
class GraduateStudent extends Student {
}
 
class Student extends Person {
  public String toString() {
    return "Student";
  }
}
 
class Person extends Object {
  public String toString() {
    return "Person";
  }
}
```

An object of a subtype can be used wherever its supertype value is required.
This feature is known as _polymorphism_.

When the method m(Object x) is executed, the argument x’s toString method is
invoked. x may be an instance of GraduateStudent, Student, Person, or Object.
Classes GraduateStudent, Student, Person, and Object have their own
implementation of the toString method. Which implementation is used will be
determined dynamically by the Java Virtual Machine at runtime. This capability
is known as dynamic binding.

Polymorphism allows methods to be used generically for a wide range of object
arguments. This is known as **generic programming**. If a method’s parameter
type is a superclass (e.g., Object), you may pass an object to this method of
any of the parameter’s subclasses (e.g., Student or String). When an object
(e.g., a Student object or a String object) is used in the method, the
particular implementation of the method of the object that is invoked (e.g.,
toString) is determined dynamically.

### Dynamic Binding

Dynamic binding works as follows: Suppose an object `o` is an instance of
classes $C_{1}$, $C_{2}$, ..., $C_{n-1}$, and $C_{n}$, where $C_{1}$ is a
subclass of $C_{2}$, $C_{2}$ is a subclass of $C_{3}$, ..., and $C_{n-1}$ is a
subclass of $C_{n}$. That is, $C_{n}$ is the most general class, and $C_{1}$ is
the most specific class. In Java, $C_{n}$ is the Object class. If `o` invokes a
method `p`, the JVM searches the implementation for the method `p` in $C_{1}$,
$C_{2}$, ..., $C_{n-1}$ and $C_{n}$, in this order, until it is found. Once an
implementation is found, the search stops and the first-found implementation is
invoked.

### Method Matching vs. Binding

Matching a method signature and binding a method implementation are two issues.
The compiler finds a matching method according to parameter type, number of
parameters, and order of the parameters at compilation time. A method may be
implemented in several subclasses. The Java Virtual Machine dynamically binds
the implementation of the method at runtime.

### Casting Objects

You have already used the casting operator to convert variables of one primitive
type to another. Casting can also be used to convert an object of one class type
to another within an inheritance hierarchy. In the preceding section, the
statement

```java
m(new Student());
```

assigns the object new Student() to a parameter of the Object type. This
statement is equivalent to:

```java
Object o = new Student(); // Implicit casting
m(o);
```

The statement Object o = new Student(), known as implicit casting, is legal
because an instance of Student is automatically an instance of Object.

### Why Casting Is Necessary?

Suppose you want to assign the object reference o to a variable of the Student
type using the following statement:

```java
Student b = o;
```

A compile error would occur. Why does the statement Object o = new Student()
work and the statement Student b = o doesn’t? This is because a Student object
is always an instance of Object, but an Object is not necessarily an instance of
Student. Even though you can see that o is really a Student object, the compiler
is not so clever to know it. To tell the compiler that o is a Student object,
use an explicit casting. The syntax is similar to the one used for casting among
primitive data types. Enclose the target object type in parentheses and place it
before the object to be cast, as follows:

```java
Student b = (Student)o; // Explicit casting
```

> Explicit casting must be used when casting an object from a superclass to a
subclass.  This type of casting may not always succeed.

### The instanceof Operator

Use the `instanceof` operator to test whether an object is an instance of a
class:

```java
Object myObject = new Circle();
... // Some lines of code
/** Perform casting if myObject is an instance of Circle */
if (myObject instanceof Circle) {
  System.out.println("The circle diameter is " +
    ((Circle)myObject).getDiameter());
  ...
}
```

### The equals Method

The `equals()` method compares the contents of two objects. The default
implementation of the equals method in the Object class is as follows:

```java
public boolean equals(Object o) {
  if (o instanceof Circle) {
    return radius == ((Circle)o).radius;
  }
  else
    return false;
}
```

> The == comparison operator is used for comparing two primitive data type
values or for determining whether two objects have the same references. The
equals method is intended to test whether two objects have the same contents,
provided that the method is modified in the defining class of the objects. The
== operator is stronger than the equals method, in that the == operator checks
whether the two reference variables refer to the same object.

### The ArrayList Class

You can create an array to store objects. But the array’s size is fixed once the
array is created. Java provides the ArrayList class that can be used to store an
unlimited number of objects.

`java.util.ArralyList<E>`

ArrayList is known as a generic class with a generic type `E`. You can specify a
concrete type to replace `E` when creating an `ArrayList`. For example, the
following statement creates an `ArrayList` and assigns its reference to variable
`cities`. This `ArrayList` object can be used to store strings.

```java
ArrayList<String> cities = new ArrayList<String>();
ArrayList<String> cities = new ArrayList<>();
```

#### Array Lists from/to Arrays

Creating an ArrayList from an array of objects:

```java
String[] array = {"red", "green", "blue"};
ArrayList<String> list = new ArrayList<>(Arrays.asList(array));
```

Creating an array of objects from an ArrayList:

```java
String[] array1 = new String[list.size()];
list.toArray(array1);
```

#### max and min in an Array List

```java
String[] array = {"red", "green", "blue"};
System.out.pritnln(java.util.Collections.max(
   new ArrayList<String>(Arrays.asList(array)));
```

```java
String[] array = {"red", "green", "blue"};
System.out.pritnln(java.util.Collections.min(
  new ArrayList<String>(Arrays.asList(array)));
```

#### Shuffling an Array List

```java
Integer[] array = {3, 5, 95, 4, 15, 34, 3, 6, 5};
ArrayList<Integer> list = new
  ArrayList<>(Arrays.asList(array));
java.util.Collections.shuffle(list);
System.out.println(list);
```

### The protected Modifier

  - The `protected` modifier can be applied on data and methods in a class. A
    protected data or a `protected` method in a public class can be accessed by
    any class in the same package or its subclasses, **even if the subclasses
    are in a different package**.

  - Visibility increases in this order:
    * private, default, protected, public


### A Subclass Cannot Weaken the Accessibility

A subclass may override a protected method in its superclass and change its
visibility to public. However, a subclass cannot weaken the accessibility of a
method defined in the superclass. For example, if a method is defined as public
in the superclass, it must be defined as public in the subclass.

> The modifiers are used on classes and class members (data and methods), except
that the final modifier can also be used on local variables in a method. A final
local variable is a constant inside a method.

### The final Modifier

  - The final class cannot be extended:

```java
final class Math {
  ...
}
```

  - The final variable is a constant:

```java
final static double PI = 3.14159;
```

  - The final method cannot be
    overridden by its subclasses.


## Exceptions Handling and Text IO

  - [Exceptions Handling](file:../../../../files/summer-2020/CISC-191/week-2/exceptions_handling.ppt)


<br>

# Resources

  - [Unified Modeling Language (UML)](https://www.cs.bsu.edu/homepages/pvgestwicki/misc/uml/)
  - [Objects and Classes](file:../../../../files/summer-2020/CISC-191/week-2/objects_and_classes.ppt)
  - [Object-Oriented Thinking](file:../../../../files/summer-2020/CISC-191/week-2/object-oriented_thinking.ppt)
  - [Inheritance and Polymorphism](file:../../../../files/summer-2020/CISC-191/week-2/inheritance_and_polymorphism.ppt)
