---
title: Week 3
author: Mark Lucernas
date: 2020-06-29
summary: Linked Data Structures and Recursion
---


# Week 3: Linked Data Structures and Recursion

## Recursion

  - [Recursion](file:../../../../files/summer-2020/CISC-191/week-3/recursion.ppt)
  - [VIDEO: Java Recursion](https://www.youtube.com/watch?v=neuDuf_i8Sg)


### Recursion Java Sample Codes

  - [+Recursion Java Sample Codes](extras/recursion_sample_codes)


### Stack Overflow

Recursion enables an elegant solution to some problems. But, for large problems,
deep recursion can cause memory problems. Part of a program's memory is reserved
to support function calls. Each method call places a new **stack frame** on the
stack, for local parameters, local variables, and more method items. Upon
return, the frame is deleted.

Deep recursion could fill the stack region and cause a stack overflow, meaning a
stack frame extends beyond the memory region allocated for stack, **Stack
overflow** usually causes the program to crash and report an error like: stack
overflow error or stack overflow exception.


## List and Queues

  - [List and Queues](file:../../../../files/summer-2020/CISC-191/week-3/list-and-queues.ppt)
  - [VIDEO: Linked List in Java](https://www.youtube.com/watch?v=195KUinjBpU)


## Searching and Algorithms

  - [+Search Algorithms Java Sample Codes](extras/search_algorithms_sample_codes)

An **algorithm** is a sequence of steps for accomplishing a task. **Linear
search** is a search algorithm that starts from the beginning of a list, and
checks each element until the search key is found or the end of the list is
reached.

An algorithm's **runtime** is the time the algorithm takes to execute. If each
comparison takes 1 Âµs (1 microsecond), a linear search algorithm's runtime is up
to 1 s to search a list with 1,000,000 elements, 10 s for 10,000,000 elements,
and so on. Ex: Searching Amazon's online store, which has more than 200 million
items, could require more than 3 minutes.


### Binary Search Algorithm

  - [Binary Search](file:../../../../files/summer-2020/CISC-191/week-3/binary-search.ppt)
  - [VIDEO: Java Binary Search Tree](https://www.youtube.com/watch?v=M6lYob8STMI)
  - [VIDEO: Java Binary Search Tree 2](https://www.youtube.com/watch?v=UcOxGmj45AA)


Binary search is incredibly efficient in finding an element within a sorted
list. During each iteration or step of the algorithm, binary search reduces the
search space (i.e., the remaining elements to search within) by half. The search
terminates when the element is found or the search space is empty (element not
found). For a 32 element list, if the search key is not found, the search space
is halved to have 16 elements, then 8, 4, 2, 1, and finally none, requiring only
6 steps. For an N element list, the maximum number of steps required to reduce
the search space to an empty sublist is $[\ \log_{2} N\ ] + 1$
$$
\text{Ex. }[\ \log_{2} N\ ] + 1 = 6
$$


## AVL Trees

  - [AVL Trees](file:../../../../files/summer-2020/CISC-191/week-3/avl-trees.ppt)


## Big O Notation

  - [VIDEO: Big-O Notation in 5 Minutes](https://www.youtube.com/watch?v=__vX2sjlpXU)


Below are the Big O performance of common functions of different Java Collections.

List                 | Add  | Remove | Get  | Contains | Next | Data Structure
---------------------|------|--------|------|----------|------|---------------
ArrayList            | O(1) |  O(n)  | O(1) |   O(n)   | O(1) | Array
LinkedList           | O(1) |  O(1)  | O(n) |   O(n)   | O(1) | Linked List
CopyOnWriteArrayList | O(n) |  O(n)  | O(1) |   O(n)   | O(1) | Array

Set                   |    Add   |  Remove  | Contains |   Next   | Size | Data Structure
----------------------|----------|----------|----------|----------|------|-------------------------
HashSet               | O(1)     | O(1)     | O(1)     | O(h/n)   | O(1) | Hash Table
LinkedHashSet         | O(1)     | O(1)     | O(1)     | O(1)     | O(1) | Hash Table + Linked List
EnumSet               | O(1)     | O(1)     | O(1)     | O(1)     | O(1) | Bit Vector
TreeSet               | O(log n) | O(log n) | O(log n) | O(log n) | O(1) | Red-black tree
CopyOnWriteArraySet   | O(n)     | O(n)     | O(n)     | O(1)     | O(1) | Array
ConcurrentSkipListSet | O(log n) | O(log n) | O(log n) | O(1)     | O(n) | Skip List

Queue                   |  Offer   | Peak |   Poll   | Remove | Size | Data Structure
------------------------|----------|------|----------|--------|------|---------------
PriorityQueue           | O(log n) | O(1) | O(log n) |  O(n)  | O(1) | Priority Heap
LinkedList              | O(1)     | O(1) | O(1)     |  O(1)  | O(1) | Array
ArrayDequeue            | O(1)     | O(1) | O(1)     |  O(n)  | O(1) | Linked List
ConcurrentLinkedQueue   | O(1)     | O(1) | O(1)     |  O(n)  | O(n) | Linked List
ArrayBlockingQueue      | O(1)     | O(1) | O(1)     |  O(n)  | O(1) | Array
PriorirityBlockingQueue | O(log n) | O(1) | O(log n) |  O(n)  | O(1) | Priority Heap
SynchronousQueue        | O(1)     | O(1) | O(1)     |  O(n)  | O(1) | None!
DelayQueue              | O(log n) | O(1) | O(log n) |  O(n)  | O(1) | Priority Heap
LinkedBlockingQueue     | O(1)     | O(1) | O(1)     |  O(n)  | O(1) | Linked List

Map                   |   Get    | ContainsKey |   Next   | Data Structure
----------------------|----------|-------------|----------|-------------------------
HashMap               | O(1)     |   O(1)      | O(h / n) | Hash Table
LinkedHashMap         | O(1)     |   O(1)      | O(1)     | Hash Table + Linked List
IdentityHashMap       | O(1)     |   O(1)      | O(h / n) | Array
WeakHashMap           | O(1)     |   O(1)      | O(h / n) | Hash Table
EnumMap               | O(1)     |   O(1)      | O(1)     | Array
TreeMap               | O(log n) |   O(log n)  | O(log n) | Red-black tree
ConcurrentHashMap     | O(1)     |   O(1)      | O(h / n) | Hash Tables
ConcurrentSkipListMap | O(log n) |   O(log n)  | O(1)     | Skip List


Source:

  - [Java Collections Complexity cheatsheet](https://gist.github.com/iSergius/e06963c6eca0a639023666097227427c)


## Mist Topics

  - [VIDEO: Data Structures: Trees](https://www.youtube.com/watch?v=oSWTXtMglKE)
  - [VIDEO: Java Sort Algorithm](https://www.youtube.com/watch?v=JUOyKSZScW0)


<br>

# Resources

  - [Recursion](file:../../../../files/summer-2020/CISC-191/week-3/recursion.ppt)
  - [VIDEO: Java Recursion](https://www.youtube.com/watch?v=neuDuf_i8Sg)
  - [List and Queues](file:../../../../files/summer-2020/CISC-191/week-3/list-and-queues.ppt)
  - [VIDEO: Linked List in Java](https://www.youtube.com/watch?v=195KUinjBpU)
  - [Binary Search](file:../../../../files/summer-2020/CISC-191/week-3/binary-search.ppt)
  - [VIDEO: Java Binary Search Tree](https://www.youtube.com/watch?v=M6lYob8STMI)
  - [VIDEO: Java Binary Search Tree 2](https://www.youtube.com/watch?v=UcOxGmj45AA)
  - [AVL Trees](file:../../../../files/summer-2020/CISC-191/week-3/avl-trees.ppt)
  - [VIDEO: Data Structures: Trees](https://www.youtube.com/watch?v=oSWTXtMglKE)
  - [VIDEO: Java Sort Algorithm](https://www.youtube.com/watch?v=JUOyKSZScW0)
  - [VIDEO: Big-O Notation in 5 Minutes](https://www.youtube.com/watch?v=__vX2sjlpXU)
  - [Java Collections Complexity cheatsheet](https://gist.github.com/iSergius/e06963c6eca0a639023666097227427c)


Textbook

  * [Andrew Huang CISC 191: Intermediate Java Programming - zyBooks](https://www.zybooks.com/)
    - Chapter 11 Recursion
    - Chapter 17 Searching and algorithms
