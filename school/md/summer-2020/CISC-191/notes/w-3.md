---
title: Week 3
author: Mark Lucernas
date: 2020-06-29
summary: Linked Data Structures and Recursion
---


# Week 3: Linked Data Structures and Recursion

## Recursion

  - [Recursion](file:../../../../files/summer-2020/CISC-191/week-3/recursion.ppt)
  - [VIDEO: Java Recursion](https://www.youtube.com/watch?v=neuDuf_i8Sg)


### Recursion Java Sample Codes

  - [+Recursion Java Sample Codes](extras/recursion_sample_codes)


### Stack Overflow

Recursion enables an elegant solution to some problems. But, for large problems,
deep recursion can cause memory problems. Part of a program's memory is reserved
to support function calls. Each method call places a new **stack frame** on the
stack, for local parameters, local variables, and more method items. Upon
return, the frame is deleted.

Deep recursion could fill the stack region and cause a stack overflow, meaning a
stack frame extends beyond the memory region allocated for stack, **Stack
overflow** usually causes the program to crash and report an error like: stack
overflow error or stack overflow exception.


## List and Queues

  - [List and Queues](file:../../../../files/summer-2020/CISC-191/week-3/list-and-queues.ppt)
  - [VIDEO: Linked List in Java](https://www.youtube.com/watch?v=195KUinjBpU)


## Searching and Algorithms

  - [+Search Algorithms Java Sample Codes](extras/search_algorithms_sample_codes)

An **algorithm** is a sequence of steps for accomplishing a task. **Linear
search** is a search algorithm that starts from the beginning of a list, and
checks each element until the search key is found or the end of the list is
reached.

An algorithm's **runtime** is the time the algorithm takes to execute. If each
comparison takes 1 Âµs (1 microsecond), a linear search algorithm's runtime is up
to 1 s to search a list with 1,000,000 elements, 10 s for 10,000,000 elements,
and so on. Ex: Searching Amazon's online store, which has more than 200 million
items, could require more than 3 minutes.


### Binary Search Algorithm

  - [Binary Search](file:../../../../files/summer-2020/CISC-191/week-3/binary-search.ppt)
  - [VIDEO: Java Binary Search Tree](https://www.youtube.com/watch?v=M6lYob8STMI)
  - [VIDEO: Java Binary Search Tree 2](https://www.youtube.com/watch?v=UcOxGmj45AA)


Binary search is incredibly efficient in finding an element within a sorted
list. During each iteration or step of the algorithm, binary search reduces the
search space (i.e., the remaining elements to search within) by half. The search
terminates when the element is found or the search space is empty (element not
found). For a 32 element list, if the search key is not found, the search space
is halved to have 16 elements, then 8, 4, 2, 1, and finally none, requiring only
6 steps. For an N element list, the maximum number of steps required to reduce
the search space to an empty sublist is $[\ \log_{2} N\ ] + 1$

$$
\text{Ex. }[\ \log_{2} N\ ] + 1 = 6
$$


## AVL Trees

  - [AVL Trees](file:../../../../files/summer-2020/CISC-191/week-3/avl-trees.ppt)


## Big O Notation

  - [+Big O Performance of Some Common Functions of Java Collections](extras/big_o_java_collections.md)
  - [VIDEO: Big-O Notation in 5 Minutes](https://www.youtube.com/watch?v=__vX2sjlpXU)


Big O notation is a mathematical way of describing how a function (running time
of an algorithm) generally behaves in relation to the input size. In Big O
notation, all functions that have the same growth rate (as determined by the
highest order term of the function) are characterized using the same Big O
notation. In essence, all functions that have the same growth rate are
considered equivalent in Big O notation.

Given a function that describes the running time of an algorithm, the Big O
notation for that function can be determined using the following rules:

  1. If $f(x)$ is a sum of several terms, the highest order term (the one with
     the fastest growth rate) is kept and others are discarded.
  2. If $f(x)$ has a term that is a product of several factors, all constants
     (those that are not in terms of x) are omitted.


Rules for determining Big O notation of composite functions.

| Composite function   | Big O notation          |
|----------------------|-------------------------|
| $c \cdot O(f(x))$    | $O(f(x))$               |
| $c + O(f(x))$        | $O(f(x))$               |
| $g(x) \cdot O(f(x))$ | $O(g(x) \cdot O(f(x)))$ |
| $g(x) + O(f(x))$     | $O(g(x) + O(f(x)))$     |


Sample 1:

$$
\text{Algorithm steps: } 5 + 13 \cdot N + 7 \cdot N^{2}
$$

$$
\begin{aligned}
\text{Big O notation: } O(5 + 13 \cdot N + 7 \cdot N^{2}) &= O(7 \cdot N^{2}) \\
 &= O(N^{2})
\end{aligned}
$$

Sample 2:

$$
\text{Algorithm steps: } 10 \cdot O(N^{2})
$$

$$
\text{Big O notation: } 10 \cdot O(N^{2}) = O(10 \cdot N^{2}) = O(N^{2})
$$

Sample 3:

$$
\text{Algorithm steps: } 3 \cdot N \cdot O(N^{2})
$$

$$
\begin{aligned}
\text{Big O notation: } &= 3 \cdot N \cdot O(N^{2}) \\
 &= O(3 \cdot N \cdot N^{2}) \\
 &= O(3 \cdot N^{3}) = O(N^{3})
\end{aligned}
$$

Sample 4:

$$
\text{Algorithm steps: } 2 \cdot N^{3} + O(N^{2})
$$

$$
\begin{aligned}
\text{Big O notation: } &= 2 \cdot N^{3} + O(N^{2}) \\
 &= O(2 \cdot N^{3} + N^{2}) \\
 &= O(N^{3})
\end{aligned}
$$

Growth rates for different input sizes.

One consideration in evaluating algorithms is that the efficiency of the
algorithm is most critical for large input sizes. Small inputs are likely to
result in fast running times because $N$ is small, so efficiency is less of a
concern. The table below shows the runtime to perform $f(N)$ instructions for
different functions $f$ and different values of $N$. For large $N$, the
difference in computation time varies greatly with the rate of growth of the
function $f$.  The data assumes that a single instruction takes $1 \mu s$ to
execute.

| Function  | N = 10      | N = 100              | N = 1000    | N = 10000          | N = 100000           |                      |
|-----------|-------------|----------------------|-------------|--------------------|----------------------|----------------------|
| $log N$   | $3.3 \mu s$ | $5.65 \mu s$         | $6.6 \mu s$ | $9.9 \mu s$        | $13.3 \mu s$         | $16.6 \mu s$         |
| $N$       | $10 \mu s$  | $50 \mu s$           | $100 \mu s$ | $1000 \mu s$       | $10 ms$              | $0.1 s$              |
| $N log N$ | $.03 ms$    | $.28 ms$             | $.66 ms$    | $.099 s$           | $.132 s$             | $1.66 s$             |
| $N^{2}$   | $.1 ms$     | $2.5 ms$             | $10 ms$     | $1 s$              | $100 s$              | $2.7 \text{ hours}$  |
| $N^{3}$   | $1 ms$      | $.125 s$             | $1 s$       | $16.7 \text{ min}$ | $11.57 \text{ days}$ | $31.7 \text{ years}$ |
| $2^{N}$   | $.001 s$    | $35.7 \text{ years}$ | $*$         | $*$                | $*$                  | $*$                  |


## Mist Topics

  - [VIDEO: Data Structures: Trees](https://www.youtube.com/watch?v=oSWTXtMglKE)
  - [VIDEO: Java Sort Algorithm](https://www.youtube.com/watch?v=JUOyKSZScW0)


<br>

# Resources

  - [Recursion](file:../../../../files/summer-2020/CISC-191/week-3/recursion.ppt)
  - [VIDEO: Java Recursion](https://www.youtube.com/watch?v=neuDuf_i8Sg)
  - [List and Queues](file:../../../../files/summer-2020/CISC-191/week-3/list-and-queues.ppt)
  - [VIDEO: Linked List in Java](https://www.youtube.com/watch?v=195KUinjBpU)
  - [Binary Search](file:../../../../files/summer-2020/CISC-191/week-3/binary-search.ppt)
  - [VIDEO: Java Binary Search Tree](https://www.youtube.com/watch?v=M6lYob8STMI)
  - [VIDEO: Java Binary Search Tree 2](https://www.youtube.com/watch?v=UcOxGmj45AA)
  - [AVL Trees](file:../../../../files/summer-2020/CISC-191/week-3/avl-trees.ppt)
  - [VIDEO: Big-O Notation in 5 Minutes](https://www.youtube.com/watch?v=__vX2sjlpXU)
  - [VIDEO: Data Structures: Trees](https://www.youtube.com/watch?v=oSWTXtMglKE)
  - [VIDEO: Java Sort Algorithm](https://www.youtube.com/watch?v=JUOyKSZScW0)


Textbook

  * [Andrew Huang CISC 191: Intermediate Java Programming - zyBooks](https://www.zybooks.com/)
    - Chapter 11 Recursion
    - Chapter 17 Searching and algorithms
