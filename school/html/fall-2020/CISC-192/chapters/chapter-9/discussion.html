<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Mark Lucernas">

    <title>Chapter 9 Discussion</title>

    <!-- For animated toc sidebar -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css" rel="stylesheet" type="text/css">
    <link href="../../../../../../templates/css/animated-toc.css" rel="stylesheet">
    <!-- Bootstrap core CSS -->
    <link href="../../../../../../templates/css/bootstrap.min.css" rel="stylesheet">
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="../../../../../../templates/css/ie10-viewport-bug-workaround.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="../../../../../../templates/css/dashboard.css" rel="stylesheet">
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  </head>

  <body>

<!-- Nav bar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">School Wiki</a>
        </div>
        <!-- <div id="navbar" class="navbar-collapse collapse">                                                                                                                 -->
        <!--   <ul class="nav navbar-nav">                                                                                                                                      -->
        <!--     <li><a href="#">doc1</a></li>                                                                                                                                  -->
        <!--     <li><a href="#">doc2</a></li>                                                                                                                                  -->
        <!--     <li><a href="#">doc3</a></li>                                                                                                                                  -->
        <!--     <li class="dropdown">                                                                                                                                          -->
        <!--       <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a> -->
        <!--       <ul class="dropdown-menu">                                                                                                                                   -->
        <!--         <li><a href="#">Action</a></li>                                                                                                                            -->
        <!--         <li><a href="#">Another action</a></li>                                                                                                                    -->
        <!--         <li><a href="#">Something else here</a></li>                                                                                                               -->
        <!--         <li role="separator" class="divider"></li>                                                                                                                 -->
        <!--         <li class="dropdown-header">Nav header</li>                                                                                                                -->
        <!--         <li><a href="#">Separated link</a></li>                                                                                                                    -->
        <!--         <li><a href="#">One more separated link</a></li>                                                                                                           -->
        <!--       </ul>                                                                                                                                                        -->
        <!--     </li>                                                                                                                                                          -->
        <!--   </ul>                                                                                                                                                            -->
        <!-- </div>                                                                                                                                                             -->
      </div>
    </nav>

    <div class="container-fluid">
      <div class="row">

<!-- Table of Contents -->
        <nav id="sidebar" class="col-sm-3 col-md-2 sidebar toc">
          <ul>
          <li><a href="#discussion">Discussion</a><ul>
          <li><a href="#two-linear-sorting-algorithms">Two linear sorting algorithms</a></li>
          <li><a href="#two-tree-sorting-algorithms">Two tree sorting algorithms</a></li>
          </ul></li>
          <li><a href="#resources">Resources</a></li>
          </ul>
          <svg class="toc-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#444" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
          </svg>
        </nav>
        <div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main">

<!-- Header -->
          <header>
            <div class="jumbotron">
              <div class="page-header">
                <a href="../../../../index.html">Wiki Root</a> | <a href="../index.html">index</a>
                <h1 class="title">
                  Chapter 9 Discussion
                </h1>
              </div>
            </div>
          </header>
          <div class="h5 text-muted">
            <h5 class="author">Mark Lucernas</h5>
            <h5 class="date">Nov 18, 2020</h5>
          </div>

<!-- Contents -->
          <article class="contents">
<h1 id="discussion">Discussion</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=__vX2sjlpXU">📺 Big-O notation in 5 minutes – The basics</a> <a href="https://www.youtube.com/watch?v=__vX2sjlpXU" title="Big-O notation in 5 minutes -- The basics"><img src="https://img.youtube.com/vi/__vX2sjlpXU/0.jpg" alt="Big-O notation in 5 minutes – The basics" /></a></li>
</ul>
<p><strong>Please review time complexities of data structure operations and sorting algorithms. These are taken from <a href="https://www.bigocheatsheet.com/" class="uri">https://www.bigocheatsheet.com/</a> . If you are preparing for a job coding interview, I suggest you know all of these inside out. However, for this discussion, please choose and compare:</strong></p>
<ol type="1">
<li><strong>Two linear sorting algorithms</strong></li>
<li><strong>Two tree sorting algorithms</strong></li>
</ol>
<p>In your comparisons:</p>
<ol type="1">
<li><strong>Explain the algorithm, using code snippets to help explain.</strong></li>
<li><strong>Describe a good use case for each sorting algorithm.</strong></li>
<li><strong>Describe a bad use case for each sorting algorithm.</strong></li>
</ol>
<h3 id="two-linear-sorting-algorithms">Two linear sorting algorithms</h3>
<p><strong>Insertion Sort</strong></p>
<p>Insertion sort is an algorithm that loops through an array from beginning to end linearly, with each iteration checks to see if the number at the current index is in the right place going backwards. This algorithm makes sure that as it goes forward, the numbers behind the current index are already sorted.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="dt">void</span> insertionSort(<span class="dt">int</span> [], <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="dt">void</span> printArrayValues(<span class="dt">int</span> [], <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="dt">int</span> arr[] = { <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span> };</a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="dt">int</span> nArr = <span class="kw">sizeof</span>(arr) / <span class="kw">sizeof</span>(arr[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="co">// Print pre-sorted array</span></a>
<a class="sourceLine" id="cb1-12" title="12">  printArrayValues(arr, nArr);</a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14">  insertionSort(arr, nArr);</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16">  <span class="co">// Print sorted array</span></a>
<a class="sourceLine" id="cb1-17" title="17">  printArrayValues(arr, nArr);</a>
<a class="sourceLine" id="cb1-18" title="18">}</a>
<a class="sourceLine" id="cb1-19" title="19"></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="dt">void</span> insertionSort(<span class="dt">int</span> numbers[], <span class="dt">int</span> size) {</a>
<a class="sourceLine" id="cb1-21" title="21">  <span class="dt">int</span> i, j; <span class="co">// Loop counters</span></a>
<a class="sourceLine" id="cb1-22" title="22">  <span class="dt">int</span> tmp;  <span class="co">// Temporary variable for swap</span></a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24">  <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt; size; i++) {</a>
<a class="sourceLine" id="cb1-25" title="25">    j = i; <span class="co">// Catch up with the current index</span></a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="co">// Insert numbers[i] into sorted part</span></a>
<a class="sourceLine" id="cb1-27" title="27">    <span class="co">// stopping once numbers[i] in correct position</span></a>
<a class="sourceLine" id="cb1-28" title="28">    <span class="cf">while</span> (j &gt; <span class="dv">0</span> &amp;&amp; numbers[j] &lt; numbers[j - <span class="dv">1</span>]) {</a>
<a class="sourceLine" id="cb1-29" title="29">      <span class="co">// Swap numbers[j] and numbers[j - 1]</span></a>
<a class="sourceLine" id="cb1-30" title="30">      tmp = numbers[j];</a>
<a class="sourceLine" id="cb1-31" title="31">      numbers[j] = numbers[j - <span class="dv">1</span>];</a>
<a class="sourceLine" id="cb1-32" title="32">      numbers[j - <span class="dv">1</span>] = tmp;</a>
<a class="sourceLine" id="cb1-33" title="33">      j--;</a>
<a class="sourceLine" id="cb1-34" title="34">    }</a>
<a class="sourceLine" id="cb1-35" title="35">  }</a>
<a class="sourceLine" id="cb1-36" title="36">}</a>
<a class="sourceLine" id="cb1-37" title="37"></a>
<a class="sourceLine" id="cb1-38" title="38"><span class="co">// Prints all array elements in array param</span></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="dt">void</span> printArrayValues(<span class="dt">int</span> arr[], <span class="dt">unsigned</span> <span class="dt">int</span> arrSize) {</a>
<a class="sourceLine" id="cb1-40" title="40">  <span class="cf">for</span> (<span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; arrSize; i++)</a>
<a class="sourceLine" id="cb1-41" title="41">    cout &lt;&lt; arr[i] &lt;&lt; <span class="st">&quot; &quot;</span>;</a>
<a class="sourceLine" id="cb1-42" title="42">  cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb1-43" title="43">}</a></code></pre></div>
<p>OUTPUT</p>
<pre><code>5 4 3 1 2
1 2 3 4 5</code></pre>
<p><strong>Selection Sort</strong></p>
<p>This algorithm, same as insertion sort, the treats the the array as two separate parts, sorted and unsorted. Its also linear looping through each index of the array from beginning till the end, making sure that all the numbers that are passed by the outer loop are sorted. The difference is that selection finds the smallest number every iteration then place it behind the current index location.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="dt">void</span> selectionSort(<span class="dt">int</span> [], <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="dt">void</span> printArrayValues(<span class="dt">int</span> [], <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="dt">int</span> arr[] = { <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span> };</a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="dt">int</span> nArr = <span class="kw">sizeof</span>(arr) / <span class="kw">sizeof</span>(arr[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11">  <span class="co">// Print pre-sorted array</span></a>
<a class="sourceLine" id="cb3-12" title="12">  printArrayValues(arr, nArr);</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">  selectionSort(arr, nArr);</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">  <span class="co">// Print sorted array</span></a>
<a class="sourceLine" id="cb3-17" title="17">  printArrayValues(arr, nArr);</a>
<a class="sourceLine" id="cb3-18" title="18">}</a>
<a class="sourceLine" id="cb3-19" title="19"></a>
<a class="sourceLine" id="cb3-20" title="20"><span class="dt">void</span> selectionSort(<span class="dt">int</span> numbers[], <span class="dt">int</span> size) {</a>
<a class="sourceLine" id="cb3-21" title="21">  <span class="dt">int</span> i, j; <span class="co">// Loop counters</span></a>
<a class="sourceLine" id="cb3-22" title="22">  <span class="dt">int</span> indexSmallest;</a>
<a class="sourceLine" id="cb3-23" title="23">  <span class="dt">int</span> temp; <span class="co">// Temporary variable for swap</span></a>
<a class="sourceLine" id="cb3-24" title="24"></a>
<a class="sourceLine" id="cb3-25" title="25">  <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; size - <span class="dv">1</span>; ++i) {</a>
<a class="sourceLine" id="cb3-26" title="26">    <span class="co">// Find index of smallest remaining element</span></a>
<a class="sourceLine" id="cb3-27" title="27">    indexSmallest = i;</a>
<a class="sourceLine" id="cb3-28" title="28">    <span class="cf">for</span> (j = i + <span class="dv">1</span>; j &lt; size; ++j) {</a>
<a class="sourceLine" id="cb3-29" title="29">      <span class="co">// Make numbers[j] the current indexSmallest yet</span></a>
<a class="sourceLine" id="cb3-30" title="30">      <span class="co">// if its smalle than the current</span></a>
<a class="sourceLine" id="cb3-31" title="31">      <span class="cf">if</span> (numbers[j] &lt; numbers[indexSmallest]) {</a>
<a class="sourceLine" id="cb3-32" title="32">        indexSmallest = j;</a>
<a class="sourceLine" id="cb3-33" title="33">      }</a>
<a class="sourceLine" id="cb3-34" title="34">    }</a>
<a class="sourceLine" id="cb3-35" title="35"></a>
<a class="sourceLine" id="cb3-36" title="36">    <span class="co">// Swap numbers[i] and numbers[indexSmallest]</span></a>
<a class="sourceLine" id="cb3-37" title="37">    temp = numbers[i];</a>
<a class="sourceLine" id="cb3-38" title="38">    numbers[i] = numbers[indexSmallest];</a>
<a class="sourceLine" id="cb3-39" title="39">    numbers[indexSmallest] = temp;</a>
<a class="sourceLine" id="cb3-40" title="40">  }</a>
<a class="sourceLine" id="cb3-41" title="41">}</a>
<a class="sourceLine" id="cb3-42" title="42"></a>
<a class="sourceLine" id="cb3-43" title="43"><span class="co">// Prints all array elements in array param</span></a>
<a class="sourceLine" id="cb3-44" title="44"><span class="dt">void</span> printArrayValues(<span class="dt">int</span> arr[], <span class="dt">unsigned</span> <span class="dt">int</span> arrSize) {</a>
<a class="sourceLine" id="cb3-45" title="45">  <span class="cf">for</span> (<span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; arrSize; i++)</a>
<a class="sourceLine" id="cb3-46" title="46">    cout &lt;&lt; arr[i] &lt;&lt; <span class="st">&quot; &quot;</span>;</a>
<a class="sourceLine" id="cb3-47" title="47">  cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb3-48" title="48">}</a></code></pre></div>
<p>OUTPUT</p>
<pre><code>5 4 3 1 2
1 2 3 4 5</code></pre>
<p><strong>Insertion sort vs. Selection sort</strong></p>
<p>Both algorithm has the same space complexity and almost the same time complexity. Both has O(n^2) as worst case scenario, however Insertion sort has better best case scenario of Ω(n) which is linear. Personally I think selection sort is simpler than insertion sort because its like how we sort something out in the real world, finding the smallest then setting them aside. But this algorithm will inefficiently search for the smallest numbers every iteration even if it is already sorted. In contrast, however, insertion sort solves this problem where it only iterate once for an already sorted array because it compares adjacent indexes instead of looking for the smallest from the whole array.</p>
<p>A good use case of insertion sort is when you want to implement an easy sorting algorithm with a relatively faster time complexity. However, because this algorithm is linear, as the size of the array gets bigger, it becomes less efficient.</p>
<p>Selection sort however, is also a good algorithm for a quick and easy implementation for small arrays. Selection sort will always have O(n^2) for best, average and worst time complexity. Much more predictable but less inefficient. Finally, Just like insertion sort, the bigger the array gets, the more data processing this algorithm will require. Definitely appropriate for sorting arrays with millions of elements.</p>
<h3 id="two-tree-sorting-algorithms">Two tree sorting algorithms</h3>
<p><strong>Tree Sort</strong></p>
<p>Tree sort algorithm uses Binary Search Tree. It creates nodes which recursively caries 2 more nodes, left and right. The left of each node must be less than its parent node and the right must be greater than the parent node. The sorting comes in via the in-order traversal, where it would be traversing the tree starting from the lowest leftmost children node, then up to the root node, then finally traversing down to the lowest rightmost children node. If done right. the left-right in-order traversal should produce an ascending array.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">struct</span> Node {</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="co">// Tree node scafolding</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="dt">int</span> key;</a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="kw">struct</span> Node *left, *right;</a>
<a class="sourceLine" id="cb5-8" title="8">};</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">/* A utility function to create a new BST Node */</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="kw">struct</span> Node *newNode(<span class="dt">int</span> item) {</a>
<a class="sourceLine" id="cb5-12" title="12">  <span class="kw">struct</span> Node *temp = <span class="kw">new</span> Node;</a>
<a class="sourceLine" id="cb5-13" title="13">  temp-&gt;key = item;                 <span class="co">// Set item as key of Node</span></a>
<a class="sourceLine" id="cb5-14" title="14">  temp-&gt;left = temp-&gt;right = NULL;  <span class="co">// Initialize left and right to NULL</span></a>
<a class="sourceLine" id="cb5-15" title="15">  <span class="cf">return</span> temp;</a>
<a class="sourceLine" id="cb5-16" title="16">}</a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">// -------------------- PROTOTYPES -------------------- //</span></a>
<a class="sourceLine" id="cb5-19" title="19"></a>
<a class="sourceLine" id="cb5-20" title="20"><span class="dt">void</span> treeSort(<span class="dt">int</span> [], <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb5-21" title="21"><span class="dt">void</span> printArrayValues(<span class="dt">int</span> [], <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb5-22" title="22"><span class="dt">void</span> storeSorted(Node*, <span class="dt">int</span> [], <span class="dt">int</span>&amp;);</a>
<a class="sourceLine" id="cb5-23" title="23">Node* insert(Node*, <span class="dt">int</span> );</a>
<a class="sourceLine" id="cb5-24" title="24"></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="co">// -------------------- MAIN -------------------- //</span></a>
<a class="sourceLine" id="cb5-26" title="26"></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb5-28" title="28">  <span class="dt">int</span> arr[] = { <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span> };</a>
<a class="sourceLine" id="cb5-29" title="29">  <span class="dt">int</span> nArr = <span class="kw">sizeof</span>(arr) / <span class="kw">sizeof</span>(arr[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb5-30" title="30"></a>
<a class="sourceLine" id="cb5-31" title="31">  <span class="co">// Print pre-sorted array</span></a>
<a class="sourceLine" id="cb5-32" title="32">  printArrayValues(arr, nArr);</a>
<a class="sourceLine" id="cb5-33" title="33"></a>
<a class="sourceLine" id="cb5-34" title="34">  treeSort(arr, nArr);</a>
<a class="sourceLine" id="cb5-35" title="35"></a>
<a class="sourceLine" id="cb5-36" title="36">  <span class="co">// Print sorted array</span></a>
<a class="sourceLine" id="cb5-37" title="37">  printArrayValues(arr, nArr);</a>
<a class="sourceLine" id="cb5-38" title="38">}</a>
<a class="sourceLine" id="cb5-39" title="39"></a>
<a class="sourceLine" id="cb5-40" title="40"><span class="co">// -------------------- FUNCTIONS -------------------- //</span></a>
<a class="sourceLine" id="cb5-41" title="41"></a>
<a class="sourceLine" id="cb5-42" title="42"><span class="co">// Stores in-oder traversal of the BST in arr[]</span></a>
<a class="sourceLine" id="cb5-43" title="43"><span class="dt">void</span> storeSorted(Node *root, <span class="dt">int</span> arr[], <span class="dt">int</span> &amp;i) {</a>
<a class="sourceLine" id="cb5-44" title="44">  <span class="cf">if</span> (root != NULL) {</a>
<a class="sourceLine" id="cb5-45" title="45">    storeSorted(root-&gt;left, arr, i);</a>
<a class="sourceLine" id="cb5-46" title="46">    arr[i++] = root-&gt;key;</a>
<a class="sourceLine" id="cb5-47" title="47">    storeSorted(root-&gt;right, arr, i);</a>
<a class="sourceLine" id="cb5-48" title="48">  }</a>
<a class="sourceLine" id="cb5-49" title="49">}</a>
<a class="sourceLine" id="cb5-50" title="50"></a>
<a class="sourceLine" id="cb5-51" title="51"><span class="co">// A utility function to insert a new Node with given key in BST</span></a>
<a class="sourceLine" id="cb5-52" title="52">Node* insert(Node* node, <span class="dt">int</span> key) {</a>
<a class="sourceLine" id="cb5-53" title="53">  <span class="co">// If the tree is empty, return a new Node</span></a>
<a class="sourceLine" id="cb5-54" title="54">  <span class="cf">if</span> (node == NULL) <span class="cf">return</span> newNode(key);</a>
<a class="sourceLine" id="cb5-55" title="55"></a>
<a class="sourceLine" id="cb5-56" title="56">  <span class="co">// Otherwise, recur down the tree</span></a>
<a class="sourceLine" id="cb5-57" title="57">  <span class="cf">if</span> (key &lt; node-&gt;key)</a>
<a class="sourceLine" id="cb5-58" title="58">    node-&gt;left  = insert(node-&gt;left, key);</a>
<a class="sourceLine" id="cb5-59" title="59">  <span class="cf">else</span> <span class="cf">if</span> (key &gt; node-&gt;key)</a>
<a class="sourceLine" id="cb5-60" title="60">    node-&gt;right = insert(node-&gt;right, key);</a>
<a class="sourceLine" id="cb5-61" title="61"></a>
<a class="sourceLine" id="cb5-62" title="62">  <span class="co">// return the (unchanged) Node pointer</span></a>
<a class="sourceLine" id="cb5-63" title="63">  <span class="cf">return</span> node;</a>
<a class="sourceLine" id="cb5-64" title="64">}</a>
<a class="sourceLine" id="cb5-65" title="65"></a>
<a class="sourceLine" id="cb5-66" title="66"><span class="co">// This function sorts arr[0 ... n-1] using Tree Sort</span></a>
<a class="sourceLine" id="cb5-67" title="67"><span class="dt">void</span> treeSort(<span class="dt">int</span> arr[], <span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb5-68" title="68">  <span class="kw">struct</span> Node *root = NULL;</a>
<a class="sourceLine" id="cb5-69" title="69"></a>
<a class="sourceLine" id="cb5-70" title="70">  <span class="co">// Construct the BST</span></a>
<a class="sourceLine" id="cb5-71" title="71">  root = insert(root, arr[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb5-72" title="72">  <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">1</span>; i&lt;n; i++)</a>
<a class="sourceLine" id="cb5-73" title="73">    root = insert(root, arr[i]);</a>
<a class="sourceLine" id="cb5-74" title="74"></a>
<a class="sourceLine" id="cb5-75" title="75">  <span class="co">// Store in-oder traversal of the BST in arr[]</span></a>
<a class="sourceLine" id="cb5-76" title="76">  <span class="dt">int</span> i = <span class="dv">0</span>;  <span class="co">// index loop counter</span></a>
<a class="sourceLine" id="cb5-77" title="77">  storeSorted(root, arr, i);</a>
<a class="sourceLine" id="cb5-78" title="78">}</a>
<a class="sourceLine" id="cb5-79" title="79"></a>
<a class="sourceLine" id="cb5-80" title="80"><span class="co">// Prints all array elements in array param</span></a>
<a class="sourceLine" id="cb5-81" title="81"><span class="dt">void</span> printArrayValues(<span class="dt">int</span> arr[], <span class="dt">unsigned</span> <span class="dt">int</span> arrSize) {</a>
<a class="sourceLine" id="cb5-82" title="82">  <span class="cf">for</span> (<span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; arrSize; i++)</a>
<a class="sourceLine" id="cb5-83" title="83">    cout &lt;&lt; arr[i] &lt;&lt; <span class="st">&quot; &quot;</span>;</a>
<a class="sourceLine" id="cb5-84" title="84">  cout &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb5-85" title="85">}</a></code></pre></div>
<p>OUTPUT</p>
<pre><code>5 4 3 1 2
1 2 3 4 5</code></pre>
<p>Ref:</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/tree-sort/">📄 Tree Sort</a></li>
</ul>
<p><strong>AVL Tree Sort</strong></p>
<p>AVL Tree is a self-balancing Binary Search Tree where the difference between heights of left and right subtrees cannot be more than one for all nodes.</p>
<p>Tree rotation is an operation that the structure without interfering with the order of the elements on an AVL tree. wt moves one node up in the tree and one node down. It is used to change the shape of the tree, and to decrease its height by moving smaller subtrees down and larger subtrees up, resulting in improved performance of many tree operations.</p>
<p>Because the AVL Tree implementation is too long for this discussion I will just link really great implementation of an AVL Tree in C++:</p>
<ul>
<li><a href="https://www.tutorialspoint.com/cplusplus-program-to-implement-avl-tree">📄 Implementation of AVL Tree in C++</a></li>
</ul>
<p><strong>Tree sort vs. AVL Tree Sort</strong></p>
<p>Both the Tree sort and AVL Tree requires more memory to create nodes for the elements. The difference is that the AVL tree does extra work on balancing the height of the tree so that one side of the root node or a sub-node won’t be too “heavy” or too much sub-nodes to make tree traversal be more consistent. Tree sort does not self-balance its nodes making tree traversal potentially inconsistent as some tree nodes might have more sub-nodes than the others.</p>
<p>A good use case of Tree sort I can think of is when you are in need of a sorting algorithm that also stores value in a data structure such as the Binary Search Tree. Tree sort is just as worst in sorting as some of the sorting algorithms such as the Quicksort but the tree consisting of nodes can also be used retreiving data that is relatively faster than retrieving data from an array. Furthermore, an AVL Tree sort which balances the height of its nodes, at the cost of more data processing, will make for a more consistent and better time complexity.</p>
<p>However, using both of this sorting algorithms without regards for retrieving values from the data structure would be a waste of memory. There are other faster sorting algorithms such as Mergesort or Heapsort that can perform better than Tree Sort and AVL Tree Sort.</p>
<p><br></p>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=__vX2sjlpXU">📺 Big-O notation in 5 minutes – The basics</a></li>
<li><a href="https://www.geeksforgeeks.org/tree-sort/">📄 Tree Sort</a></li>
<li><a href="https://www.tutorialspoint.com/cplusplus-program-to-implement-avl-tree">📄 Implementation of AVL Tree in C++</a></li>
</ul>
          </article>
          </div>
      </div>
    </div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../../../../../templates/js/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="../../../../../../templates/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../../../../../../templates/js/ie10-viewport-bug-workaround.js"></script>
    <script>
        //document.getElementById('sidebar').getElementsByTagName('ul')[0].className += "nav nav-sidebar";

        /* ajust the height when click the toc
           the code is from https://github.com/twbs/bootstrap/issues/1768
        */
        var shiftWindow = function() { scrollBy(0, -50) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }

        /*add Bootstrap styles to tables*/
        var tables = document.getElementsByTagName("table");
        for(var i = 0; i < tables.length; ++i){
            tables[i].className += "table table-bordered table-hover";
        }
    </script>
    <script src="../../../../../../templates/js/animated-toc.js"></script>
  </body>
</html>
