<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="generator" content="pandoc">
    <meta name="description" content="">
    <meta name="author" content="Mark Lucernas">

    <title>Chapter 10 Discussion</title>

    <!-- For animated toc sidebar -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css" rel="stylesheet" type="text/css">
    <link href="../../../../../../templates/css/animated-toc.css" rel="stylesheet">
    <!-- Bootstrap core CSS -->
    <link href="../../../../../../templates/css/bootstrap.min.css" rel="stylesheet">
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="../../../../../../templates/css/ie10-viewport-bug-workaround.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="../../../../../../templates/css/dashboard.css" rel="stylesheet">
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
  </head>

  <body>

<!-- Nav bar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">School Wiki</a>
        </div>
        <!-- <div id="navbar" class="navbar-collapse collapse">                                                                                                                 -->
        <!--   <ul class="nav navbar-nav">                                                                                                                                      -->
        <!--     <li><a href="#">doc1</a></li>                                                                                                                                  -->
        <!--     <li><a href="#">doc2</a></li>                                                                                                                                  -->
        <!--     <li><a href="#">doc3</a></li>                                                                                                                                  -->
        <!--     <li class="dropdown">                                                                                                                                          -->
        <!--       <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Dropdown <span class="caret"></span></a> -->
        <!--       <ul class="dropdown-menu">                                                                                                                                   -->
        <!--         <li><a href="#">Action</a></li>                                                                                                                            -->
        <!--         <li><a href="#">Another action</a></li>                                                                                                                    -->
        <!--         <li><a href="#">Something else here</a></li>                                                                                                               -->
        <!--         <li role="separator" class="divider"></li>                                                                                                                 -->
        <!--         <li class="dropdown-header">Nav header</li>                                                                                                                -->
        <!--         <li><a href="#">Separated link</a></li>                                                                                                                    -->
        <!--         <li><a href="#">One more separated link</a></li>                                                                                                           -->
        <!--       </ul>                                                                                                                                                        -->
        <!--     </li>                                                                                                                                                          -->
        <!--   </ul>                                                                                                                                                            -->
        <!-- </div>                                                                                                                                                             -->
      </div>
    </nav>

    <div class="container-fluid">
      <div class="row">

<!-- Table of Contents -->
        <nav id="sidebar" class="col-sm-3 col-md-2 sidebar toc">
          <ul>
          <li><a href="#discussion">Discussion</a></li>
          <li><a href="#resources">Resources</a></li>
          </ul>
          <svg class="toc-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
            <path stroke="#444" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
          </svg>
        </nav>
        <div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main">

<!-- Header -->
          <header>
            <div class="jumbotron">
              <div class="page-header">
                <a href="../../../../index.html">Wiki Root</a> | <a href="../index.html">index</a>
                <h1 class="title">
                  Chapter 10 Discussion
                </h1>
              </div>
            </div>
          </header>
          <div class="h5 text-muted">
            <h5 class="author">Mark Lucernas</h5>
            <h5 class="date">Dec 03, 2020</h5>
          </div>

<!-- Contents -->
          <article class="contents">
<h1 id="discussion">Discussion</h1>
<ol type="1">
<li>Compare and contrast the 3 base smart pointer types in the Gaddis textbook and 1 more from <a href="https://www.boost.org/doc/libs/1_73_0/libs/smart_ptr/doc/html/smart_ptr.html">📄 Boost</a>.</li>
<li>Explain one good use case for each of the 4 smart pointer types. Feel free to use diagrams or sample code to help justify each use case. Copy and pasted research is welcomed, but make sure to cite your sources.</li>
</ol>
<p>Smart pointers are objects that wraps an ordinary pointer to an owned object. They help solve the problems with memory management such as <em>memory leaks</em>, <em>dangling pointers</em>, <em>double deletion</em>, etc., which can be problematic if not managed properly.</p>
<p>The central concpet behind smart pointers is <em>ownership of dynamically allocated memory</em>. A smart pointer is said to <em>own</em> or <em>manage</em> the object that it points to.</p>
<p><strong>NOTE: To avoid memory leaks, objects that are managed by smart pointers should have no other references to them.</strong></p>
<p><code>unique_ptr</code></p>
<p>Unique pointers are used when a dynamically allocated object is to be owned by a single pointer. <code>unique_ptr</code> cannot be initialized with the value of another <code>unique_ptr</code> object. Similarly, you cannot assign one <code>unique_ptr</code> object to another.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="co">/* Pointer to a dynamically allocated storage should immediately be passed to</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">     a smart pointer constructor without first assigning it to a pointer</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">     variable to avoid memory leaks. */</span></a>
<a class="sourceLine" id="cb1-9" title="9">  unique_ptr&lt;<span class="dt">int</span>&gt; uPtr(<span class="kw">new</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb1-10" title="10">  *uPtr = <span class="dv">99</span>;</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12">  cout &lt;&lt; *uPtr &lt;&lt; endl;  <span class="co">// Prints: 99</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14">  uPtr = <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16">  <span class="co">// With Arrays</span></a>
<a class="sourceLine" id="cb1-17" title="17"></a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="at">const</span> <span class="dt">int</span> SIZE = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb1-19" title="19">  unique_ptr&lt;<span class="dt">int</span>[]&gt; uPtrArr(<span class="kw">new</span> <span class="dt">int</span>[SIZE]);</a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21">  <span class="co">// Set array elements 0 - 4</span></a>
<a class="sourceLine" id="cb1-22" title="22">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; SIZE; i++) {</a>
<a class="sourceLine" id="cb1-23" title="23">    uPtrArr[i] = i;</a>
<a class="sourceLine" id="cb1-24" title="24">  }</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">  <span class="co">// Print the array elements</span></a>
<a class="sourceLine" id="cb1-27" title="27">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; SIZE; i++) {</a>
<a class="sourceLine" id="cb1-28" title="28">    cout &lt;&lt; uPtrArr[i] &lt;&lt; <span class="st">&quot; &quot;</span>;  <span class="co">// Prints: 0 1 2 3 4</span></a>
<a class="sourceLine" id="cb1-29" title="29">  }</a>
<a class="sourceLine" id="cb1-30" title="30">  cout &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-31" title="31"></a>
<a class="sourceLine" id="cb1-32" title="32">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-33" title="33">}</a></code></pre></div>
<p>However, C++ provides a <code>move()</code> library function that can be used to transfer ownership from one unique pointer to another.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1">unique_ptr&lt;<span class="dt">int</span>&gt; uPtr1(<span class="kw">new</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb2-2" title="2">*uPtr1 = <span class="dv">15</span>;</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">// unique_ptr&lt;int&gt; uPtr3 = uPtr1; // Illegal initialization</span></a>
<a class="sourceLine" id="cb2-5" title="5">unique_ptr&lt;<span class="dt">int</span>&gt; uPtr3;            <span class="co">// Ok</span></a>
<a class="sourceLine" id="cb2-6" title="6">uPtr3 = move(uPtr1);              <span class="co">// Transfer ownership from uptr1 to uptr3</span></a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">cout &lt;&lt; *uPtr3 &lt;&lt; end;            <span class="co">// Prints: 15</span></a></code></pre></div>
<p>Additionally, <code>make_unique&lt;T&gt;()</code> or <code>make_unique&lt;T []&gt;()</code> is used to create a unique pointer to an object or array of objects of type <em>T</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// Creates unique pointer of type Thing</span></a>
<a class="sourceLine" id="cb3-2" title="2">unique_ptr&lt;Thing&gt; uPtr = make_unique&lt;Thing&gt;();</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">// Creates unique array pointer of type Thing of size 5</span></a>
<a class="sourceLine" id="cb3-4" title="4">unique_ptr&lt;Thing[]&gt; uPtrArr = make_unique&lt;Thing[]&gt;(<span class="dv">5</span>);</a></code></pre></div>
<p><code>shared_ptr</code></p>
<p>Shared pointers jointly maintain a count of the pointers that currently share ownership of an object. this <em>reference count</em> increases as additional pointers are set to point to the objet and decreases as pointers detach frm the object</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="dt">int</span>* rPtr = <span class="kw">new</span> <span class="dt">int</span>(<span class="dv">99</span>);</a>
<a class="sourceLine" id="cb4-7" title="7">  shared_ptr&lt;<span class="dt">int</span>&gt; sPtr1(rPtr);</a>
<a class="sourceLine" id="cb4-8" title="8">  shared_ptr&lt;<span class="dt">int</span>&gt; sPtr2 = sPtr1;  <span class="co">// Becomes a member of the same group as sPtr1</span></a>
<a class="sourceLine" id="cb4-9" title="9">  shared_ptr&lt;<span class="dt">int</span>&gt; sPtr3 = sPtr2;  <span class="co">// Becomes a member of the same group as sPtr2</span></a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="co">// shared_ptr&lt;int&gt; sptr4(rPtr); // Error: Double dipping. Not allowed</span></a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12">  cout &lt;&lt; *rPtr &lt;&lt; endl;  <span class="co">// Prints: 99</span></a>
<a class="sourceLine" id="cb4-13" title="13">  cout &lt;&lt; *sPtr1 &lt;&lt; endl; <span class="co">// Prints: 99</span></a>
<a class="sourceLine" id="cb4-14" title="14">  cout &lt;&lt; *sPtr2 &lt;&lt; endl; <span class="co">// Prints: 99</span></a>
<a class="sourceLine" id="cb4-15" title="15">  cout &lt;&lt; *sPtr3 &lt;&lt; endl; <span class="co">// Prints: 99</span></a>
<a class="sourceLine" id="cb4-16" title="16"></a>
<a class="sourceLine" id="cb4-17" title="17">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-18" title="18">}</a></code></pre></div>
<p>Similar to <code>make_unique</code>, shared pointers has <code>make_shared</code> constructor to initialize objects of type <em>T</em>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// Creates int shared pointer with a value of 99</span></a>
<a class="sourceLine" id="cb5-2" title="2">shared_ptr&lt;<span class="dt">int</span>&gt; sPtrInt = make_shared&lt;<span class="dt">int</span>&gt;(<span class="dv">99</span>);</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">// Creates int shared pointer array of size 5</span></a>
<a class="sourceLine" id="cb5-4" title="4">shared_ptr&lt;<span class="dt">int</span>[]&gt; sPtrArrInt = make_shared&lt;<span class="dt">int</span>[]&gt;(<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// Creates shared pointer of type Person</span></a>
<a class="sourceLine" id="cb5-7" title="7">shared_ptr&lt;Person&gt; sPtrPerson = make_shared&lt;Person&gt;();</a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">// Creates shared pointer array of type Person of size 5</span></a>
<a class="sourceLine" id="cb5-9" title="9">shared_ptr&lt;Person[]&gt; sPtrArrPerson = make_shared&lt;Person[]&gt;(<span class="dv">5</span>);</a></code></pre></div>
<p><code>weak_ptr</code></p>
<p>Smart pointer that holds a non-owning (“weak”) reference to an object that is managed by <code>shared_ptr</code>. It must be converted to <code>shared_ptr</code> in order to access the referenced object.</p>
<p>Weak pointer holds temporary ownership when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else. Needs to be converted to <code>shared_ptr</code> to assume temporary ownership.</p>
<p>Weak pointer is useful for locating objects if it’s still around but doesn’t keep it around if nothing else needs it. Great for caching.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb6-6" title="6">  shared_ptr&lt;<span class="dt">int</span>&gt; sPtr(<span class="kw">new</span> <span class="dt">int</span>(<span class="dv">5</span>));</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">  weak_ptr&lt;<span class="dt">int</span>&gt; wPtr1;</a>
<a class="sourceLine" id="cb6-9" title="9">  weak_ptr&lt;<span class="dt">int</span>&gt; wPtr2 (wPtr1);</a>
<a class="sourceLine" id="cb6-10" title="10">  weak_ptr&lt;<span class="dt">int</span>&gt; wPtr3 (sPtr);</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="co">/* use_count() is a member function of weak_ptr that returns the number of</span></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="co">     shared_ptr objects that share ownership over the same pointer as this</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="co">     object. */</span></a>
<a class="sourceLine" id="cb6-15" title="15">  cout &lt;&lt; <span class="st">&quot;use_count:&quot;</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb6-16" title="16">  cout &lt;&lt; <span class="st">&quot;wPtr1: &quot;</span> &lt;&lt; wPtr1.use_count() &lt;&lt; endl; <span class="co">// Prints: wPtr1: 0</span></a>
<a class="sourceLine" id="cb6-17" title="17">  cout &lt;&lt; <span class="st">&quot;wPtr2: &quot;</span> &lt;&lt; wPtr2.use_count() &lt;&lt; endl; <span class="co">// Prints: wPtr2: 0</span></a>
<a class="sourceLine" id="cb6-18" title="18">  cout &lt;&lt; <span class="st">&quot;wPtr3: &quot;</span> &lt;&lt; wPtr3.use_count() &lt;&lt; endl; <span class="co">// Prints: wPtr3: 1</span></a>
<a class="sourceLine" id="cb6-19" title="19"></a>
<a class="sourceLine" id="cb6-20" title="20">  cout &lt;&lt; endl;</a>
<a class="sourceLine" id="cb6-21" title="21"></a>
<a class="sourceLine" id="cb6-22" title="22">  cout &lt;&lt; <span class="st">&quot;Pointer value:&quot;</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb6-23" title="23"></a>
<a class="sourceLine" id="cb6-24" title="24">  <span class="co">// Convert weak pointer to shared pointer</span></a>
<a class="sourceLine" id="cb6-25" title="25">  <span class="cf">if</span> (shared_ptr&lt;<span class="dt">int</span>&gt; tmp = wPtr1.lock())   <span class="co">// Check if wPtr1 is expired</span></a>
<a class="sourceLine" id="cb6-26" title="26">    cout &lt;&lt; <span class="st">&quot;wPtr1: &quot;</span> &lt;&lt; *tmp &lt;&lt; endl;      <span class="co">// Print pointer value if not expired</span></a>
<a class="sourceLine" id="cb6-27" title="27">  <span class="cf">else</span></a>
<a class="sourceLine" id="cb6-28" title="28">    cout &lt;&lt; <span class="st">&quot;wPtr1 is expired&quot;</span> &lt;&lt; endl;     <span class="co">// wPtr1 is expired</span></a>
<a class="sourceLine" id="cb6-29" title="29"></a>
<a class="sourceLine" id="cb6-30" title="30">  <span class="co">// Convert weak pointer to shared pointer</span></a>
<a class="sourceLine" id="cb6-31" title="31">  <span class="cf">if</span> (shared_ptr&lt;<span class="dt">int</span>&gt; tmp = wPtr2.lock())   <span class="co">// Check if wPtr2 is expired</span></a>
<a class="sourceLine" id="cb6-32" title="32">    cout &lt;&lt; <span class="st">&quot;wPtr2: &quot;</span> &lt;&lt; *tmp &lt;&lt; endl;      <span class="co">// Print pointer value if not expired</span></a>
<a class="sourceLine" id="cb6-33" title="33">  <span class="cf">else</span></a>
<a class="sourceLine" id="cb6-34" title="34">    cout &lt;&lt; <span class="st">&quot;wPtr2 is expired&quot;</span> &lt;&lt; endl;     <span class="co">// wPtr2 is expired</span></a>
<a class="sourceLine" id="cb6-35" title="35"></a>
<a class="sourceLine" id="cb6-36" title="36">  <span class="co">// Convert weak pointer to shared pointer</span></a>
<a class="sourceLine" id="cb6-37" title="37">  <span class="cf">if</span> (shared_ptr&lt;<span class="dt">int</span>&gt; tmp = wPtr3.lock())   <span class="co">// Check if wPtr3 is expired</span></a>
<a class="sourceLine" id="cb6-38" title="38">    cout &lt;&lt; <span class="st">&quot;wPtr3: &quot;</span> &lt;&lt; *tmp &lt;&lt; endl;      <span class="co">// Print pointer value if not expired</span></a>
<a class="sourceLine" id="cb6-39" title="39">  <span class="cf">else</span></a>
<a class="sourceLine" id="cb6-40" title="40">    cout &lt;&lt; <span class="st">&quot;wPtr3 is expired&quot;</span> &lt;&lt; endl;     <span class="co">// wPtr3 is expired</span></a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42">  cout &lt;&lt; <span class="st">&quot;sPtr: &quot;</span> &lt;&lt; *sPtr &lt;&lt; endl;        <span class="co">// Prints sPtr pointer value</span></a>
<a class="sourceLine" id="cb6-43" title="43"></a>
<a class="sourceLine" id="cb6-44" title="44">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-45" title="45">}</a></code></pre></div>
<p>OUTPUT</p>
<pre><code>use_count:
wPtr1: 0
wPtr2: 0
wPtr3: 1

Pointer value:
wPtr1 is expired
wPtr2 is expired
wPtr3: 5
sPtr: 5</code></pre>
<p>Sources:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">📄 cppreference - weak_ptr</a></li>
<li><a href="https://stackoverflow.com/a/21877073/11850077">📄 When is std::weak_ptr useful?</a></li>
</ul>
<p><code>scoped_ptr</code></p>
<p>Stores a pointer to a dynamically allocated object. The object pointed to is guaranteed to be deleted, either on destruction of the <code>scopted_ptr</code>, or via an explicit reset.</p>
<p><code>scoped_ptr</code> is a simple solution for simple needs. It supplies a basic “resource acquisition is initialization” facility, without shared-ownership or transfer-of-ownership semantics.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="pp">#include </span><span class="im">&lt;boost/scoped_ptr.hpp&gt;</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">struct</span> Shoe { ~Shoe() { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Buckle my shoe</span><span class="sc">\n</span><span class="st">&quot;</span>; } };</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">class</span> MyClass {</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="ex">boost::</span>scoped_ptr&lt;<span class="dt">int</span>&gt; ptr;</a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb8-9" title="9">    MyClass() : ptr(<span class="kw">new</span> <span class="dt">int</span>) { *ptr = <span class="dv">0</span>; }</a>
<a class="sourceLine" id="cb8-10" title="10">    <span class="dt">int</span> add_one() { <span class="cf">return</span> ++*ptr; }</a>
<a class="sourceLine" id="cb8-11" title="11">};</a>
<a class="sourceLine" id="cb8-12" title="12"></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb8-14" title="14">{</a>
<a class="sourceLine" id="cb8-15" title="15">    <span class="ex">boost::</span>scoped_ptr&lt;Shoe&gt; x(<span class="kw">new</span> Shoe);</a>
<a class="sourceLine" id="cb8-16" title="16">    MyClass my_instance;</a>
<a class="sourceLine" id="cb8-17" title="17">    <span class="bu">std::</span>cout &lt;&lt; my_instance.add_one() &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</a>
<a class="sourceLine" id="cb8-18" title="18">    <span class="bu">std::</span>cout &lt;&lt; my_instance.add_one() &lt;&lt; <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>;</a>
<a class="sourceLine" id="cb8-19" title="19">}</a></code></pre></div>
<p>OUTPUT</p>
<pre><code>1
2
Buckle my shoe</code></pre>
<p>The primary reason to use scoped_ptr rather than <code>std::auto_ptr</code> or <code>std::unique_ptr</code> is to let readers of your code know that you intend “resource acquisition is initialization” to be applied only for the current scope, and have no intent to transfer ownership.</p>
<p>Source:</p>
<ul>
<li><a href="https://www.boost.org/doc/libs/1_73_0/libs/smart_ptr/doc/html/smart_ptr.html.html#scoped_ptr">📄 Boost - scoped_ptr: Scoped Object Ownership</a></li>
</ul>
<p><br></p>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://www.boost.org/doc/libs/1_73_0/libs/smart_ptr/doc/html/smart_ptr.html">📄 Boost</a></li>
<li><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">📄 cppreference - weak_ptr</a></li>
<li><a href="https://stackoverflow.com/a/21877073/11850077">📄 When is std::weak_ptr useful?</a></li>
</ul>
<p>Textbook:</p>
<ul>
<li>Starting Out with C++: Early Objects by Tony Gaddis, Judy Walters, Godfrey Muganda</li>
</ul>
          </article>
          </div>
      </div>
    </div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../../../../../templates/js/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="../../../../../../templates/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../../../../../../templates/js/ie10-viewport-bug-workaround.js"></script>
    <script>
        //document.getElementById('sidebar').getElementsByTagName('ul')[0].className += "nav nav-sidebar";

        /* ajust the height when click the toc
           the code is from https://github.com/twbs/bootstrap/issues/1768
        */
        var shiftWindow = function() { scrollBy(0, -50) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }

        /*add Bootstrap styles to tables*/
        var tables = document.getElementsByTagName("table");
        for(var i = 0; i < tables.length; ++i){
            tables[i].className += "table table-bordered table-hover";
        }
    </script>
    <script src="../../../../../../templates/js/animated-toc.js"></script>
  </body>
</html>
